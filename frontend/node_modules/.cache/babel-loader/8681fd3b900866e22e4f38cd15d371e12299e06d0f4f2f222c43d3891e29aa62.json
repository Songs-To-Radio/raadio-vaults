{"ast":null,"code":"var rawPipe = function rawPipe() {\n  var res;\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  while (fns.length) {\n    res = fns.shift()(res);\n  }\n  return res;\n};\nvar isIterable = function isIterable(obj) {\n  return obj && (typeof obj[Symbol.asyncIterator] === 'function' || typeof obj[Symbol.iterator] === 'function' || typeof obj.next === 'function' // Probably, right?\n  );\n};\n\nvar isDuplex = function isDuplex(obj) {\n  return obj && typeof obj.sink === 'function' && isIterable(obj.source);\n};\nvar duplexPipelineFn = function duplexPipelineFn(duplex) {\n  return function (source) {\n    duplex.sink(source); // TODO: error on sink side is unhandled rejection - this is the same as pull streams\n    return duplex.source;\n  };\n};\nvar pipe = function pipe() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(fns[0])) {\n    var duplex = fns[0];\n    fns[0] = function () {\n      return duplex.source;\n    };\n    // Iterable at start: wrap in function\n  } else if (isIterable(fns[0])) {\n    var source = fns[0];\n    fns[0] = function () {\n      return source;\n    };\n  }\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink;\n    }\n  }\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (var i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i]);\n      }\n    }\n  }\n  return rawPipe.apply(void 0, fns);\n};\nmodule.exports = pipe;\nmodule.exports.pipe = pipe;\nmodule.exports.rawPipe = rawPipe;\nmodule.exports.isIterable = isIterable;\nmodule.exports.isDuplex = isDuplex;","map":{"version":3,"names":["rawPipe","res","fns","length","shift","isIterable","obj","Symbol","asyncIterator","iterator","next","isDuplex","sink","source","duplexPipelineFn","duplex","pipe","i","module","exports"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/it-pipe/index.js"],"sourcesContent":["const rawPipe = (...fns) => {\n  let res\n  while (fns.length) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isIterable = obj => obj && (\n  typeof obj[Symbol.asyncIterator] === 'function' ||\n  typeof obj[Symbol.iterator] === 'function' ||\n  typeof obj.next === 'function' // Probably, right?\n)\n\nconst isDuplex = obj => obj && typeof obj.sink === 'function' && isIterable(obj.source)\n\nconst duplexPipelineFn = duplex => source => {\n  duplex.sink(source) // TODO: error on sink side is unhandled rejection - this is the same as pull streams\n  return duplex.source\n}\n\nconst pipe = (...fns) => {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(fns[0])) {\n    const duplex = fns[0]\n    fns[0] = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(fns[0])) {\n    const source = fns[0]\n    fns[0] = () => source\n  }\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nmodule.exports = pipe\nmodule.exports.pipe = pipe\nmodule.exports.rawPipe = rawPipe\nmodule.exports.isIterable = isIterable\nmodule.exports.isDuplex = isDuplex\n"],"mappings":"AAAA,IAAMA,OAAO,GAAG,SAAVA,OAAO,GAAe;EAC1B,IAAIC,GAAG;EAAA,kCADWC,GAAG;IAAHA,GAAG;EAAA;EAErB,OAAOA,GAAG,CAACC,MAAM,EAAE;IACjBF,GAAG,GAAGC,GAAG,CAACE,KAAK,EAAE,CAACH,GAAG,CAAC;EACxB;EACA,OAAOA,GAAG;AACZ,CAAC;AAED,IAAMI,UAAU,GAAG,SAAbA,UAAU,CAAGC,GAAG;EAAA,OAAIA,GAAG,KAC3B,OAAOA,GAAG,CAACC,MAAM,CAACC,aAAa,CAAC,KAAK,UAAU,IAC/C,OAAOF,GAAG,CAACC,MAAM,CAACE,QAAQ,CAAC,KAAK,UAAU,IAC1C,OAAOH,GAAG,CAACI,IAAI,KAAK,UAAU,CAAC;EAAA,CAChC;AAAA;;AAED,IAAMC,QAAQ,GAAG,SAAXA,QAAQ,CAAGL,GAAG;EAAA,OAAIA,GAAG,IAAI,OAAOA,GAAG,CAACM,IAAI,KAAK,UAAU,IAAIP,UAAU,CAACC,GAAG,CAACO,MAAM,CAAC;AAAA;AAEvF,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAGC,MAAM;EAAA,OAAI,UAAAF,MAAM,EAAI;IAC3CE,MAAM,CAACH,IAAI,CAACC,MAAM,CAAC,EAAC;IACpB,OAAOE,MAAM,CAACF,MAAM;EACtB,CAAC;AAAA;AAED,IAAMG,IAAI,GAAG,SAAPA,IAAI,GAAe;EAAA,mCAARd,GAAG;IAAHA,GAAG;EAAA;EAClB;EACA,IAAIS,QAAQ,CAACT,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;IACpB,IAAMa,MAAM,GAAGb,GAAG,CAAC,CAAC,CAAC;IACrBA,GAAG,CAAC,CAAC,CAAC,GAAG;MAAA,OAAMa,MAAM,CAACF,MAAM;IAAA;IAC9B;EACA,CAAC,MAAM,IAAIR,UAAU,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;IAC7B,IAAMW,MAAM,GAAGX,GAAG,CAAC,CAAC,CAAC;IACrBA,GAAG,CAAC,CAAC,CAAC,GAAG;MAAA,OAAMW,MAAM;IAAA;EACvB;EAEA,IAAIX,GAAG,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB;IACA,IAAIQ,QAAQ,CAACT,GAAG,CAACA,GAAG,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;MACjCD,GAAG,CAACA,GAAG,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGD,GAAG,CAACA,GAAG,CAACC,MAAM,GAAG,CAAC,CAAC,CAACS,IAAI;IAChD;EACF;EAEA,IAAIV,GAAG,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB;IACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,GAAG,CAACC,MAAM,GAAG,CAAC,EAAEc,CAAC,EAAE,EAAE;MACvC,IAAIN,QAAQ,CAACT,GAAG,CAACe,CAAC,CAAC,CAAC,EAAE;QACpBf,GAAG,CAACe,CAAC,CAAC,GAAGH,gBAAgB,CAACZ,GAAG,CAACe,CAAC,CAAC,CAAC;MACnC;IACF;EACF;EAEA,OAAOjB,OAAO,eAAIE,GAAG,CAAC;AACxB,CAAC;AAEDgB,MAAM,CAACC,OAAO,GAAGH,IAAI;AACrBE,MAAM,CAACC,OAAO,CAACH,IAAI,GAAGA,IAAI;AAC1BE,MAAM,CAACC,OAAO,CAACnB,OAAO,GAAGA,OAAO;AAChCkB,MAAM,CAACC,OAAO,CAACd,UAAU,GAAGA,UAAU;AACtCa,MAAM,CAACC,OAAO,CAACR,QAAQ,GAAGA,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}