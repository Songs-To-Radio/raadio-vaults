{"ast":null,"code":"import _defineProperty from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport function pack(_x) {\n  return _pack.apply(this, arguments);\n}\nfunction _pack() {\n  _pack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {\n    var input, userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves, blockstore, rootEntry, root, _yield$CarWriter$crea, writer, carOut, carOutIter, writingPromise, writeAll, out;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            input = _ref.input, userBlockstore = _ref.blockstore, hasher = _ref.hasher, maxChunkSize = _ref.maxChunkSize, maxChildrenPerNode = _ref.maxChildrenPerNode, wrapWithDirectory = _ref.wrapWithDirectory, rawLeaves = _ref.rawLeaves;\n            if (!(!input || Array.isArray(input) && !input.length)) {\n              _context3.next = 3;\n              break;\n            }\n            throw new Error('missing input file(s)');\n          case 3:\n            blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore(); // Consume the source\n            _context3.next = 6;\n            return last(pipe(getNormaliser(input), function (source) {\n              return importer(source, blockstore, _objectSpread(_objectSpread({}, unixfsImporterOptionsDefault), {}, {\n                hasher: hasher || unixfsImporterOptionsDefault.hasher,\n                maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n                maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n                wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n                rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n              }));\n            }));\n          case 6:\n            rootEntry = _context3.sent;\n            if (!(!rootEntry || !rootEntry.cid)) {\n              _context3.next = 9;\n              break;\n            }\n            throw new Error('given input could not be parsed correctly');\n          case 9:\n            root = rootEntry.cid;\n            _context3.next = 12;\n            return CarWriter.create([root]);\n          case 12:\n            _yield$CarWriter$crea = _context3.sent;\n            writer = _yield$CarWriter$crea.writer;\n            carOut = _yield$CarWriter$crea.out;\n            carOutIter = carOut[Symbol.asyncIterator]();\n            writeAll = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, block;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context.prev = 2;\n                        _iterator = _asyncIterator(blockstore.blocks());\n                      case 4:\n                        _context.next = 6;\n                        return _iterator.next();\n                      case 6:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                          _context.next = 13;\n                          break;\n                        }\n                        block = _step.value;\n                        _context.next = 10;\n                        return writer.put(block);\n                      case 10:\n                        _iteratorAbruptCompletion = false;\n                        _context.next = 4;\n                        break;\n                      case 13:\n                        _context.next = 19;\n                        break;\n                      case 15:\n                        _context.prev = 15;\n                        _context.t0 = _context[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t0;\n                      case 19:\n                        _context.prev = 19;\n                        _context.prev = 20;\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context.next = 24;\n                          break;\n                        }\n                        _context.next = 24;\n                        return _iterator.return();\n                      case 24:\n                        _context.prev = 24;\n                        if (!_didIteratorError) {\n                          _context.next = 27;\n                          break;\n                        }\n                        throw _iteratorError;\n                      case 27:\n                        return _context.finish(24);\n                      case 28:\n                        return _context.finish(19);\n                      case 29:\n                        _context.next = 31;\n                        return writer.close();\n                      case 31:\n                        if (userBlockstore) {\n                          _context.next = 34;\n                          break;\n                        }\n                        _context.next = 34;\n                        return blockstore.close();\n                      case 34:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n              }));\n              return function writeAll() {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n            out = _defineProperty({}, Symbol.asyncIterator, function () {\n              if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n              }\n              // don't start writing until the user starts consuming the iterator\n              writingPromise = writeAll();\n              return {\n                next: function next() {\n                  return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var result;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _context2.next = 2;\n                            return carOutIter.next();\n                          case 2:\n                            result = _context2.sent;\n                            if (!result.done) {\n                              _context2.next = 6;\n                              break;\n                            }\n                            _context2.next = 6;\n                            return writingPromise;\n                          case 6:\n                            return _context2.abrupt(\"return\", result);\n                          case 7:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }))();\n                }\n              };\n            });\n            return _context3.abrupt(\"return\", {\n              root: root,\n              out: out\n            });\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _pack.apply(this, arguments);\n}","map":{"version":3,"names":["last","pipe","CarWriter","importer","getNormaliser","MemoryBlockStore","unixfsImporterOptionsDefault","pack","input","userBlockstore","blockstore","hasher","maxChunkSize","maxChildrenPerNode","wrapWithDirectory","rawLeaves","Array","isArray","length","Error","source","rootEntry","cid","root","create","writer","carOut","out","carOutIter","Symbol","asyncIterator","writeAll","blocks","block","put","close","writingPromise","next","result","done"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/ipfs-car/dist/esm/pack/index.js"],"sourcesContent":["import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}