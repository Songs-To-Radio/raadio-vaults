{"ast":null,"code":"import _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport var CarIndexer = /*#__PURE__*/function (_Symbol$asyncIterator) {\n  function CarIndexer(version, roots, iterator) {\n    _classCallCheck(this, CarIndexer);\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  _createClass(CarIndexer, [{\n    key: \"version\",\n    get: function get() {\n      return this._version;\n    }\n  }, {\n    key: \"getRoots\",\n    value: function () {\n      var _getRoots = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this._roots);\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getRoots() {\n        return _getRoots.apply(this, arguments);\n      }\n      return getRoots;\n    }()\n  }, {\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      return this._iterator;\n    }\n  }], [{\n    key: \"fromBytes\",\n    value: function () {\n      var _fromBytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(bytes) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (bytes instanceof Uint8Array) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new TypeError('fromBytes() requires a Uint8Array');\n              case 2:\n                return _context2.abrupt(\"return\", decodeIndexerComplete(bytesReader(bytes)));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function fromBytes(_x) {\n        return _fromBytes.apply(this, arguments);\n      }\n      return fromBytes;\n    }()\n  }, {\n    key: \"fromIterable\",\n    value: function () {\n      var _fromIterable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(asyncIterable) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function'))) {\n                  _context3.next = 2;\n                  break;\n                }\n                throw new TypeError('fromIterable() requires an async iterable');\n              case 2:\n                return _context3.abrupt(\"return\", decodeIndexerComplete(asyncIterableReader(asyncIterable)));\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function fromIterable(_x2) {\n        return _fromIterable.apply(this, arguments);\n      }\n      return fromIterable;\n    }()\n  }]);\n  return CarIndexer;\n}(Symbol.asyncIterator);\nfunction decodeIndexerComplete(_x3) {\n  return _decodeIndexerComplete.apply(this, arguments);\n}\nfunction _decodeIndexerComplete() {\n  _decodeIndexerComplete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(reader) {\n    var decoder, _yield$decoder$header, version, roots;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            decoder = createDecoder(reader);\n            _context4.next = 3;\n            return decoder.header();\n          case 3:\n            _yield$decoder$header = _context4.sent;\n            version = _yield$decoder$header.version;\n            roots = _yield$decoder$header.roots;\n            return _context4.abrupt(\"return\", new CarIndexer(version, roots, decoder.blocksIndex()));\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _decodeIndexerComplete.apply(this, arguments);\n}","map":{"version":3,"names":["asyncIterableReader","bytesReader","createDecoder","CarIndexer","version","roots","iterator","_version","_roots","_iterator","bytes","Uint8Array","TypeError","decodeIndexerComplete","asyncIterable","Symbol","asyncIterator","reader","decoder","header","blocksIndex"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@ipld/car/esm/lib/indexer.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}"],"mappings":";;;;AAAA,SACEA,mBAAmB,EACnBC,WAAW,EACXC,aAAa,QACR,cAAc;AACrB,WAAaC,UAAU;EACrB,oBAAYC,OAAO,EAAEC,KAAK,EAAEC,QAAQ,EAAE;IAAA;IACpC,IAAI,CAACC,QAAQ,GAAGH,OAAO;IACvB,IAAI,CAACI,MAAM,GAAGH,KAAK;IACnB,IAAI,CAACI,SAAS,GAAGH,QAAQ;EAC3B;EAAC;IAAA;IAAA,KACD,eAAc;MACZ,OAAO,IAAI,CAACC,QAAQ;IACtB;EAAC;IAAA;IAAA;MAAA,2EACD;QAAA;UAAA;YAAA;cAAA;gBAAA,iCACS,IAAI,CAACC,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACnB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OACD,iBAAyB;MACvB,OAAO,IAAI,CAACC,SAAS;IACvB;EAAC;IAAA;IAAA;MAAA,4EACD,kBAAuBC,KAAK;QAAA;UAAA;YAAA;cAAA;gBAAA,IACpBA,KAAK,YAAYC,UAAU;kBAAA;kBAAA;gBAAA;gBAAA,MACzB,IAAIC,SAAS,CAAC,mCAAmC,CAAC;cAAA;gBAAA,kCAEnDC,qBAAqB,CAACZ,WAAW,CAACS,KAAK,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjD;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,+EACD,kBAA0BI,aAAa;QAAA;UAAA;YAAA;cAAA;gBAAA,MACjC,CAACA,aAAa,IAAI,EAAE,OAAOA,aAAa,CAACC,MAAM,CAACC,aAAa,CAAC,KAAK,UAAU,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MAC1E,IAAIJ,SAAS,CAAC,2CAA2C,CAAC;cAAA;gBAAA,kCAE3DC,qBAAqB,CAACb,mBAAmB,CAACc,aAAa,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjE;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAdAC,MAAM,CAACC,aAAa;AAetB,SACcH,qBAAqB;EAAA;AAAA;AAAA;EAAA,oFAApC,kBAAqCI,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YACnCC,OAAO,GAAGhB,aAAa,CAACe,MAAM,CAAC;YAAA;YAAA,OACNC,OAAO,CAACC,MAAM,EAAE;UAAA;YAAA;YAAxCf,OAAO,yBAAPA,OAAO;YAAEC,KAAK,yBAALA,KAAK;YAAA,kCACd,IAAIF,UAAU,CAACC,OAAO,EAAEC,KAAK,EAAEa,OAAO,CAACE,WAAW,EAAE,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAC7D;EAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}