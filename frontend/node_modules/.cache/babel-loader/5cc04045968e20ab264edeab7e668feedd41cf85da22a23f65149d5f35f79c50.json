{"ast":null,"code":"import { NFTStorage, File, Blob } from \"nft.storage\";\nimport axios from \"axios\";\nimport { v4 } from \"uuid\";\nexport const endPoint = \"http://localhost:2000\";\nexport const nftStorageEndPoint = \"https://nftstorage.link/ipfs\";\nasync function uploadToServer(ipfsUrl, wallet_address, title) {\n  try {\n    let res = await fetch(`${endPoint}/create-vault`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        controller: wallet_address,\n        ipfsUrl,\n        mediaTitle: title\n      }),\n      headers: {\n        \"content-type\": \"application/json\"\n      }\n    });\n    return res.status;\n  } catch (error) {\n    throw error;\n  }\n}\nconst API_KEY = process.env.NFT_STORAGE_API_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweGE5M0I4NGFlNThkMDNkOTAwQjc5MzExOGEzNDQ2ZEZCZUU5NTVERmEiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY1MTUxMDYyMDg2MCwibmFtZSI6IlNUUiAtIE1hcmtldHBsYWNlICJ9.D71kmGtnh1wOLBF2BfVqMtuCPk79wvEiFxuhpuKgqwA\";\nconst client = new NFTStorage({\n  token: API_KEY\n});\nasync function createMetadata(image) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n    const cid = await client.storeBlob(content);\n    console.log(\"this is the image cid \", \"https://nftstorage.link/ipfs/\" + cid);\n    return cid;\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function uploadToIpfsAndServer(image, name, description, wallet_address, web2) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n    const baseURI = await client.store({\n      name,\n      video: content,\n      image: content,\n      description,\n      description,\n      collection: name,\n      web2_metadata: web2\n    });\n    console.log(baseURI);\n    return await uploadToServer(baseURI.url, wallet_address, name);\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function getVaults(address) {\n  try {\n    let res = await fetch(`${endPoint}/get-vaults/${address}`);\n    // if(res.status != 200 || res.status != 201) throw(res);\n    res = await res.json();\n    return res;\n  } catch (error) {\n    throw error;\n  }\n}\nexport function parseUrl(link, neg) {\n  link = link.replace(\"ipfs://\", \"\");\n  if (neg) return link;\n  return nftStorageEndPoint + \"/\" + link;\n}\nexport async function getMetadata(link, id) {\n  try {\n    link = link.replace(\"ipfs://\", \"\");\n    link = nftStorageEndPoint + \"/\" + link;\n    let res = await axios(link);\n    let res2;\n    if (id) {\n      res2 = await axios(`${endPoint}/metadata/${id}`);\n    }\n    return id ? res2.data : res.data;\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function getUser(addr) {\n  try {\n    let res = await axios(`${endPoint}/metadata/${addr}`);\n    res.sta;\n    return res.data;\n  } catch (error) {\n    throw error;\n  }\n}","map":{"version":3,"names":["NFTStorage","File","Blob","axios","v4","endPoint","nftStorageEndPoint","uploadToServer","ipfsUrl","wallet_address","title","res","fetch","method","body","JSON","stringify","controller","mediaTitle","headers","status","error","API_KEY","process","env","NFT_STORAGE_API_KEY","client","token","createMetadata","image","url","URL","createObjectURL","blob","content","type","split","cid","storeBlob","console","log","uploadToIpfsAndServer","name","description","web2","baseURI","store","video","collection","web2_metadata","getVaults","address","json","parseUrl","link","neg","replace","getMetadata","id","res2","data","getUser","addr","sta"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/src/api/api.js"],"sourcesContent":["import { NFTStorage, File, Blob } from \"nft.storage\";\nimport axios from \"axios\";\nimport { v4 } from \"uuid\";\n\nexport const endPoint = \"http://localhost:2000\";\nexport const nftStorageEndPoint = \"https://nftstorage.link/ipfs\";\n\nasync function uploadToServer(ipfsUrl, wallet_address, title) {\n  try {\n    let res = await fetch(`${endPoint}/create-vault`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        controller: wallet_address,\n        ipfsUrl,\n        mediaTitle: title,\n      }),\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n\n    return res.status;\n  } catch (error) {\n    throw error;\n  }\n}\n\nconst API_KEY =\n  process.env.NFT_STORAGE_API_KEY ||\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweGE5M0I4NGFlNThkMDNkOTAwQjc5MzExOGEzNDQ2ZEZCZUU5NTVERmEiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY1MTUxMDYyMDg2MCwibmFtZSI6IlNUUiAtIE1hcmtldHBsYWNlICJ9.D71kmGtnh1wOLBF2BfVqMtuCPk79wvEiFxuhpuKgqwA\";\nconst client = new NFTStorage({ token: API_KEY });\n\nasync function createMetadata(image) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n    const cid = await client.storeBlob(content);\n    console.log(\n      \"this is the image cid \",\n      \"https://nftstorage.link/ipfs/\" + cid\n    );\n    return cid;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport async function uploadToIpfsAndServer(\n  image,\n  name,\n  description,\n  wallet_address,\n  web2\n) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n\n    const baseURI = await client.store({\n      name,\n      video: content,\n      image: content,\n      description,\n      description,\n      collection: name,\n      web2_metadata: web2,\n    });\n    console.log(baseURI);\n    return await uploadToServer(baseURI.url, wallet_address, name);\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport async function getVaults(address) {\n  try {\n    let res = await fetch(`${endPoint}/get-vaults/${address}`);\n    // if(res.status != 200 || res.status != 201) throw(res);\n    res = await res.json();\n    return res;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport function parseUrl(link, neg) {\n  link = link.replace(\"ipfs://\", \"\");\n  if(neg) return link;\n  return nftStorageEndPoint + \"/\" + link;\n}\n\nexport async function getMetadata(link, id) {\n  try {\n    link = link.replace(\"ipfs://\", \"\");\n    link = nftStorageEndPoint + \"/\" + link;\n    let res = await axios(link);\n    let res2;\n    if(id){\n        res2 = await axios(`${endPoint}/metadata/${id}`);\n    }\n    return id? res2.data : res.data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n\nexport async function getUser(addr){\n    try {\n        let res = await axios(`${endPoint}/metadata/${addr}`);\n        res.sta\n        return res.data;\n    } catch (error) {\n        throw(error)\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}