{"ast":null,"code":"import _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  var headerBytes = dagCborEncode({\n    version: 1,\n    roots: roots\n  });\n  var varintBytes = varint.encode(headerBytes.length);\n  var header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    setRoots: function setRoots(roots) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var bytes;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                bytes = createHeader(roots);\n                _context.next = 3;\n                return writer.write(bytes);\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    writeBlock: function writeBlock(block) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var cid, bytes;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cid = block.cid, bytes = block.bytes;\n                _context2.next = 3;\n                return writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n              case 3:\n                _context2.next = 5;\n                return writer.write(cid.bytes);\n              case 5:\n                if (!bytes.length) {\n                  _context2.next = 8;\n                  break;\n                }\n                _context2.next = 8;\n                return writer.write(bytes);\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    close: function close() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", writer.end());\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  };\n}\nexport { createEncoder };","map":{"version":3,"names":["varint","encode","dagCborEncode","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@ipld/car/esm/lib/encoder.js"],"sourcesContent":["import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {cid, bytes} = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport {\n  createEncoder\n};"],"mappings":";;AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,MAAM,IAAIC,aAAa,QAAQ,gBAAgB;AACxD,OAAO,SAASC,YAAY,CAACC,KAAK,EAAE;EAClC,IAAMC,WAAW,GAAGH,aAAa,CAAC;IAChCI,OAAO,EAAE,CAAC;IACVF,KAAK,EAALA;EACF,CAAC,CAAC;EACF,IAAMG,WAAW,GAAGP,MAAM,CAACC,MAAM,CAACI,WAAW,CAACG,MAAM,CAAC;EACrD,IAAMC,MAAM,GAAG,IAAIC,UAAU,CAACH,WAAW,CAACC,MAAM,GAAGH,WAAW,CAACG,MAAM,CAAC;EACtEC,MAAM,CAACE,GAAG,CAACJ,WAAW,EAAE,CAAC,CAAC;EAC1BE,MAAM,CAACE,GAAG,CAACN,WAAW,EAAEE,WAAW,CAACC,MAAM,CAAC;EAC3C,OAAOC,MAAM;AACf;AACA,SAASG,aAAa,CAACC,MAAM,EAAE;EAC7B,OAAO;IACCC,QAAQ,oBAACV,KAAK,EAAE;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACdW,KAAK,GAAGZ,YAAY,CAACC,KAAK,CAAC;gBAAA;gBAAA,OAC3BS,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAC3B,CAAC;IACKE,UAAU,sBAACC,KAAK,EAAE;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACfC,GAAG,GAAWD,KAAK,CAAnBC,GAAG,EAAEJ,KAAK,GAAIG,KAAK,CAAdH,KAAK;gBAAA;gBAAA,OACXF,MAAM,CAACG,KAAK,CAAC,IAAIN,UAAU,CAACV,MAAM,CAACC,MAAM,CAACkB,GAAG,CAACJ,KAAK,CAACP,MAAM,GAAGO,KAAK,CAACP,MAAM,CAAC,CAAC,CAAC;cAAA;gBAAA;gBAAA,OAC5EK,MAAM,CAACG,KAAK,CAACG,GAAG,CAACJ,KAAK,CAAC;cAAA;gBAAA,KACzBA,KAAK,CAACP,MAAM;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACRK,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAE7B,CAAC;IACKK,KAAK,mBAAG;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,kCACLP,MAAM,CAACQ,GAAG,EAAE;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IACrB;EACF,CAAC;AACH;AACA,SACET,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}