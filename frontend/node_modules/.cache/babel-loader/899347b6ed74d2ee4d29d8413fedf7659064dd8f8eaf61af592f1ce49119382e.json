{"ast":null,"code":"import _toConsumableArray from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport * as Block from 'multiformats/block';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport { Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL, GATEWAY } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport var Token = /*#__PURE__*/function () {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  function Token(ipnft, url, data) {\n    _classCallCheck(this, Token);\n    /** @readonly */\n    this.ipnft = ipnft;\n    /** @readonly */\n    this.url = url;\n    /** @readonly */\n    this.data = data;\n    Object.defineProperties(this, {\n      ipnft: {\n        enumerable: true,\n        writable: false\n      },\n      url: {\n        enumerable: true,\n        writable: false\n      },\n      data: {\n        enumerable: false,\n        writable: false\n      }\n    });\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  _createClass(Token, [{\n    key: \"embed\",\n    value: function embed() {\n      return Token.embed(this);\n    }\n\n    /**\n     * @template {TokenInput} T\n     * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n     * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n     */\n  }], [{\n    key: \"embed\",\n    value: function embed(_ref) {\n      var data = _ref.data;\n      return _embed(data, {\n        gateway: GATEWAY\n      });\n    }\n\n    /**\n     * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n     * Token instance from it. Where values are discovered `Blob` (or `File`)\n     * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n     * prefixed CID with an optional path).\n     *\n     * @example\n     * ```js\n     * const cat = new File(['...'], 'cat.png')\n     * const kitty = new File(['...'], 'kitty.png')\n     * const { token, car } = await Token.encode({\n     *   name: 'hello'\n     *   image: cat\n     *   properties: {\n     *     extra: {\n     *       image: kitty\n     *     }\n     *   }\n     * })\n     * ```\n     *\n     * @template {TokenInput} T\n     * @param {T} input\n     * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n     */\n  }, {\n    key: \"encode\",\n    value: function () {\n      var _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input) {\n        var blockstore, _mapTokenInputBlobs, _mapTokenInputBlobs2, blobs, meta, data, dag, _iterator, _step, _step$value, dotPath, blob, name, content, _yield$pack2, cid, href, path, _yield$pack, metadataJsonCid, block;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                blockstore = new Blockstore();\n                _mapTokenInputBlobs = mapTokenInputBlobs(input), _mapTokenInputBlobs2 = _slicedToArray(_mapTokenInputBlobs, 2), blobs = _mapTokenInputBlobs2[0], meta = _mapTokenInputBlobs2[1];\n                /** @type {EncodedBlobUrl<T>} */\n                data = JSON.parse(JSON.stringify(meta));\n                /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n                dag = JSON.parse(JSON.stringify(meta));\n                _iterator = _createForOfIteratorHelper(blobs.entries());\n                _context.prev = 5;\n                _iterator.s();\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 21;\n                  break;\n                }\n                _step$value = _slicedToArray(_step.value, 2), dotPath = _step$value[0], blob = _step$value[1];\n                /** @type {string|undefined} */\n                // @ts-ignore blob may be a File!\n                name = blob.name || 'blob';\n                /** @type {import('./platform.js').ReadableStream} */\n                content = blob.stream();\n                _context.next = 13;\n                return pack({\n                  input: [{\n                    path: name,\n                    content: content\n                  }],\n                  blockstore: blockstore,\n                  wrapWithDirectory: true\n                });\n              case 13:\n                _yield$pack2 = _context.sent;\n                cid = _yield$pack2.root;\n                href = new URL(\"ipfs://\".concat(cid, \"/\").concat(name));\n                path = dotPath.split('.');\n                setIn(data, path, href);\n                setIn(dag, path, cid);\n              case 19:\n                _context.next = 7;\n                break;\n              case 21:\n                _context.next = 26;\n                break;\n              case 23:\n                _context.prev = 23;\n                _context.t0 = _context[\"catch\"](5);\n                _iterator.e(_context.t0);\n              case 26:\n                _context.prev = 26;\n                _iterator.f();\n                return _context.finish(26);\n              case 29:\n                _context.next = 31;\n                return pack({\n                  input: [{\n                    path: 'metadata.json',\n                    content: JSON.stringify(data)\n                  }],\n                  blockstore: blockstore,\n                  wrapWithDirectory: false\n                });\n              case 31:\n                _yield$pack = _context.sent;\n                metadataJsonCid = _yield$pack.root;\n                _context.next = 35;\n                return Block.encode({\n                  value: _objectSpread(_objectSpread({}, dag), {}, {\n                    'metadata.json': metadataJsonCid,\n                    type: 'nft'\n                  }),\n                  codec: dagCbor,\n                  hasher: sha256\n                });\n              case 35:\n                block = _context.sent;\n                _context.next = 38;\n                return blockstore.put(block.cid, block.bytes);\n              case 38:\n                return _context.abrupt(\"return\", {\n                  cid: block.cid,\n                  token: new Token(block.cid.toString(), \"ipfs://\".concat(block.cid, \"/metadata.json\"), data),\n                  car: new BlockstoreCarReader(1, [block.cid], blockstore)\n                });\n              case 39:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[5, 23, 26, 29]]);\n      }));\n      function encode(_x) {\n        return _encode.apply(this, arguments);\n      }\n      return encode;\n    }()\n  }]);\n  return Token;\n}();\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nvar _embed = function _embed(input, options) {\n  return mapWith(input, isURL, embedURL, options);\n};\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport { _embed as embed };\nexport var decode = function decode(_ref2, paths) {\n  var ipnft = _ref2.ipnft,\n    url = _ref2.url,\n    data = _ref2.data;\n  return new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths));\n};\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nvar isURL = function isURL(value) {\n  return value instanceof URL;\n};\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nvar decodeURL = function decodeURL(state, url) {\n  return [state, new URL(url)];\n};\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nvar embedURL = function embedURL(context, url) {\n  return [context, toGatewayURL(url, context)];\n};\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nvar isObject = function isObject(value) {\n  return typeof value === 'object' && value != null;\n};\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nvar isEncodedURL = function isEncodedURL(value, assetPaths, path) {\n  return typeof value === 'string' && assetPaths.has(path.join('.'));\n};\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport var encode = function encode(input) {\n  var _mapValueWith = mapValueWith(input, isBlob, encodeBlob, new Map(), []),\n    _mapValueWith2 = _slicedToArray(_mapValueWith, 2),\n    map = _mapValueWith2[0],\n    meta = _mapValueWith2[1];\n  var form = new FormData();\n  var _iterator2 = _createForOfIteratorHelper(map.entries()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        k = _step2$value[0],\n        v = _step2$value[1];\n      form.set(k, v);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  form.set('meta', JSON.stringify(meta));\n  return form;\n};\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nvar encodeBlob = function encodeBlob(data, blob, path) {\n  data.set(path.join('.'), blob);\n  return [data, undefined];\n};\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nvar isBlob = function isBlob(value) {\n  return value instanceof Blob;\n};\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nvar mapTokenInputBlobs = function mapTokenInputBlobs(input) {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n};\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport var mapWith = function mapWith(input, p, f, state) {\n  var _mapValueWith3 = mapValueWith(input, p, f, state, []),\n    _mapValueWith4 = _slicedToArray(_mapValueWith3, 2),\n    output = _mapValueWith4[1];\n  return output;\n};\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nvar mapValueWith = function mapValueWith(input, p, f, state, path) {\n  return p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject(input) ? mapObjectWith(input, p, f, state, path) : [state, /** @type {any} */input];\n};\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nvar mapObjectWith = function mapObjectWith(input, p, f, init, path) {\n  var state = init;\n  var output = /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */{};\n  for (var _i = 0, _Object$entries = Object.entries(input); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      key = _Object$entries$_i[0],\n      value = _Object$entries$_i[1];\n    var _mapValueWith5 = mapValueWith(value, p, f, state, [].concat(_toConsumableArray(path), [key])),\n      _mapValueWith6 = _slicedToArray(_mapValueWith5, 2),\n      next = _mapValueWith6[0],\n      out = _mapValueWith6[1];\n    // @ts-ignore\n    output[key] = out;\n    state = next;\n  }\n  return [state, output];\n};\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nvar mapArrayWith = function mapArrayWith(input, p, f, init, path) {\n  var output = /** @type {unknown[]} */[];\n  var state = init;\n  var _iterator3 = _createForOfIteratorHelper(input.entries()),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        index = _step3$value[0],\n        element = _step3$value[1];\n      var _mapValueWith7 = mapValueWith(element, p, f, state, [].concat(_toConsumableArray(path), [index])),\n        _mapValueWith8 = _slicedToArray(_mapValueWith7, 2),\n        next = _mapValueWith8[0],\n        out = _mapValueWith8[1];\n      output[index] = out;\n      state = next;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return [state, /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */output];\n};\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nvar setIn = function setIn(object, path, value) {\n  var n = path.length - 1;\n  var target = object;\n  var _iterator4 = _createForOfIteratorHelper(path.entries()),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n        index = _step4$value[0],\n        key = _step4$value[1];\n      if (index === n) {\n        target[key] = value;\n      } else {\n        target = target[key];\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n};","map":{"version":3,"names":["pack","CID","Block","sha256","dagCbor","Blob","FormData","Blockstore","toGatewayURL","GATEWAY","BlockstoreCarReader","Token","ipnft","url","data","Object","defineProperties","enumerable","writable","embed","gateway","input","blockstore","mapTokenInputBlobs","blobs","meta","JSON","parse","stringify","dag","entries","dotPath","blob","name","content","stream","path","wrapWithDirectory","cid","root","href","URL","split","setIn","metadataJsonCid","encode","value","type","codec","hasher","block","put","bytes","token","toString","car","options","mapWith","isURL","embedURL","decode","paths","isEncodedURL","decodeURL","state","context","isObject","assetPaths","has","join","mapValueWith","isBlob","encodeBlob","Map","map","form","k","v","set","undefined","p","f","output","Array","isArray","mapArrayWith","mapObjectWith","init","key","next","out","index","element","object","n","length","target"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/nft.storage/src/token.js"],"sourcesContent":["import { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Block from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      const content = blob.stream()\n      const { root: cid } = await pack({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await pack({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: dagCbor,\n      hasher: sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,IAAI,QAAQ,eAAe;AACpC,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAO,KAAKC,KAAK,MAAM,oBAAoB;AAC3C,SAASC,MAAM,QAAQ,0BAA0B;AACjD,OAAO,KAAKC,OAAO,MAAM,gBAAgB;AACzC,SAASC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,QAAQ,eAAe;AAC1D,SAASC,YAAY,EAAEC,OAAO,QAAQ,cAAc;AACpD,SAASC,mBAAmB,QAAQ,oBAAoB;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAaC,KAAK;EAChB;AACF;AACA;AACA;AACA;EACE,eAAYC,KAAK,EAAEC,GAAG,EAAEC,IAAI,EAAE;IAAA;IAC5B;IACA,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB;IACA,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd;IACA,IAAI,CAACC,IAAI,GAAGA,IAAI;IAEhBC,MAAM,CAACC,gBAAgB,CAAC,IAAI,EAAE;MAC5BJ,KAAK,EAAE;QAAEK,UAAU,EAAE,IAAI;QAAEC,QAAQ,EAAE;MAAM,CAAC;MAC5CL,GAAG,EAAE;QAAEI,UAAU,EAAE,IAAI;QAAEC,QAAQ,EAAE;MAAM,CAAC;MAC1CJ,IAAI,EAAE;QAAEG,UAAU,EAAE,KAAK;QAAEC,QAAQ,EAAE;MAAM;IAC7C,CAAC,CAAC;EACJ;EACA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,iBAAQ;MACN,OAAOP,KAAK,CAACQ,KAAK,CAAC,IAAI,CAAC;IAC1B;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAKA,qBAAuB;MAAA,IAARL,IAAI,QAAJA,IAAI;MACjB,OAAOK,MAAK,CAACL,IAAI,EAAE;QAAEM,OAAO,EAAEX;MAAQ,CAAC,CAAC;IAC1C;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAxBE;IAAA;IAAA;MAAA,yEAyBA,iBAAoBY,KAAK;QAAA;QAAA;UAAA;YAAA;cAAA;gBACjBC,UAAU,GAAG,IAAIf,UAAU,EAAE;gBAAA,sBACbgB,kBAAkB,CAACF,KAAK,CAAC,iEAAxCG,KAAK,4BAAEC,IAAI;gBAClB;gBACMX,IAAI,GAAGY,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACH,IAAI,CAAC,CAAC;gBAC7C;gBACMI,GAAG,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACH,IAAI,CAAC,CAAC;gBAAA,uCAEdD,KAAK,CAACM,OAAO,EAAE;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA,8CAAjCC,OAAO,mBAAEC,IAAI;gBACvB;gBACA;gBACMC,IAAI,GAAGD,IAAI,CAACC,IAAI,IAAI,MAAM;gBAChC;gBACMC,OAAO,GAAGF,IAAI,CAACG,MAAM,EAAE;gBAAA;gBAAA,OACDnC,IAAI,CAAC;kBAC/BqB,KAAK,EAAE,CAAC;oBAAEe,IAAI,EAAEH,IAAI;oBAAEC,OAAO,EAAPA;kBAAQ,CAAC,CAAC;kBAChCZ,UAAU,EAAVA,UAAU;kBACVe,iBAAiB,EAAE;gBACrB,CAAC,CAAC;cAAA;gBAAA;gBAJYC,GAAG,gBAATC,IAAI;gBAMNC,IAAI,GAAG,IAAIC,GAAG,kBAAWH,GAAG,cAAIL,IAAI,EAAG;gBACvCG,IAAI,GAAGL,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC;gBAC/BC,KAAK,CAAC7B,IAAI,EAAEsB,IAAI,EAAEI,IAAI,CAAC;gBACvBG,KAAK,CAACd,GAAG,EAAEO,IAAI,EAAEE,GAAG,CAAC;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA,OAGiBtC,IAAI,CAAC;kBAC3CqB,KAAK,EAAE,CAAC;oBAAEe,IAAI,EAAE,eAAe;oBAAEF,OAAO,EAAER,IAAI,CAACE,SAAS,CAACd,IAAI;kBAAE,CAAC,CAAC;kBACjEQ,UAAU,EAAVA,UAAU;kBACVe,iBAAiB,EAAE;gBACrB,CAAC,CAAC;cAAA;gBAAA;gBAJYO,eAAe,eAArBL,IAAI;gBAAA;gBAAA,OAMQrC,KAAK,CAAC2C,MAAM,CAAC;kBAC/BC,KAAK,kCACAjB,GAAG;oBACN,eAAe,EAAEe,eAAe;oBAChCG,IAAI,EAAE;kBAAK,EACZ;kBACDC,KAAK,EAAE5C,OAAO;kBACd6C,MAAM,EAAE9C;gBACV,CAAC,CAAC;cAAA;gBARI+C,KAAK;gBAAA;gBAAA,OASL5B,UAAU,CAAC6B,GAAG,CAACD,KAAK,CAACZ,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC;cAAA;gBAAA,iCAErC;kBACLd,GAAG,EAAEY,KAAK,CAACZ,GAAG;kBACde,KAAK,EAAE,IAAI1C,KAAK,CACduC,KAAK,CAACZ,GAAG,CAACgB,QAAQ,EAAE,mBACVJ,KAAK,CAACZ,GAAG,qBACnBxB,IAAI,CACL;kBACDyC,GAAG,EAAE,IAAI7C,mBAAmB,CAAC,CAAC,EAAE,CAACwC,KAAK,CAACZ,GAAG,CAAC,EAAEhB,UAAU;gBACzD,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACF;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;;AAGH;AACA;AACA;AACA;AACA;AACA;AACO,IAAMH,MAAK,GAAG,SAARA,MAAK,CAAIE,KAAK,EAAEmC,OAAO;EAAA,OAClCC,OAAO,CAACpC,KAAK,EAAEqC,KAAK,EAAEC,QAAQ,EAAEH,OAAO,CAAC;AAAA;;AAE1C;AACA;AACA;AACA;AACA;AACA;AALA;AAMA,OAAO,IAAMI,MAAM,GAAG,SAATA,MAAM,QAA0BC,KAAK;EAAA,IAAzBjD,KAAK,SAALA,KAAK;IAAEC,GAAG,SAAHA,GAAG;IAAEC,IAAI,SAAJA,IAAI;EAAA,OACvC,IAAIH,KAAK,CAACC,KAAK,EAAEC,GAAG,EAAE4C,OAAO,CAAC3C,IAAI,EAAEgD,YAAY,EAAEC,SAAS,EAAEF,KAAK,CAAC,CAAC;AAAA;;AAEtE;AACA;AACA;AACA;AACA,IAAMH,KAAK,GAAG,SAARA,KAAK,CAAIZ,KAAK;EAAA,OAAKA,KAAK,YAAYL,GAAG;AAAA;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,IAAMsB,SAAS,GAAG,SAAZA,SAAS,CAAIC,KAAK,EAAEnD,GAAG;EAAA,OAAK,CAACmD,KAAK,EAAE,IAAIvB,GAAG,CAAC5B,GAAG,CAAC,CAAC;AAAA;;AAEvD;AACA;AACA;AACA;AACA;AACA,IAAM8C,QAAQ,GAAG,SAAXA,QAAQ,CAAIM,OAAO,EAAEpD,GAAG;EAAA,OAAK,CAACoD,OAAO,EAAEzD,YAAY,CAACK,GAAG,EAAEoD,OAAO,CAAC,CAAC;AAAA;;AAExE;AACA;AACA;AACA;AACA,IAAMC,QAAQ,GAAG,SAAXA,QAAQ,CAAIpB,KAAK;EAAA,OAAK,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,IAAI,IAAI;AAAA;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA,IAAMgB,YAAY,GAAG,SAAfA,YAAY,CAAIhB,KAAK,EAAEqB,UAAU,EAAE/B,IAAI;EAAA,OAC3C,OAAOU,KAAK,KAAK,QAAQ,IAAIqB,UAAU,CAACC,GAAG,CAAChC,IAAI,CAACiC,IAAI,CAAC,GAAG,CAAC,CAAC;AAAA;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMxB,MAAM,GAAG,SAATA,MAAM,CAAIxB,KAAK,EAAK;EAC/B,oBAAoBiD,YAAY,CAACjD,KAAK,EAAEkD,MAAM,EAAEC,UAAU,EAAE,IAAIC,GAAG,EAAE,EAAE,EAAE,CAAC;IAAA;IAAnEC,GAAG;IAAEjD,IAAI;EAChB,IAAMkD,IAAI,GAAG,IAAIrE,QAAQ,EAAE;EAAA,4CACNoE,GAAG,CAAC5C,OAAO,EAAE;IAAA;EAAA;IAAlC,uDAAoC;MAAA;QAAxB8C,CAAC;QAAEC,CAAC;MACdF,IAAI,CAACG,GAAG,CAACF,CAAC,EAAEC,CAAC,CAAC;IAChB;EAAC;IAAA;EAAA;IAAA;EAAA;EACDF,IAAI,CAACG,GAAG,CAAC,MAAM,EAAEpD,IAAI,CAACE,SAAS,CAACH,IAAI,CAAC,CAAC;EACtC,OAAOkD,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAMH,UAAU,GAAG,SAAbA,UAAU,CAAI1D,IAAI,EAAEkB,IAAI,EAAEI,IAAI,EAAK;EACvCtB,IAAI,CAACgE,GAAG,CAAC1C,IAAI,CAACiC,IAAI,CAAC,GAAG,CAAC,EAAErC,IAAI,CAAC;EAC9B,OAAO,CAAClB,IAAI,EAAEiE,SAAS,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA,IAAMR,MAAM,GAAG,SAATA,MAAM,CAAIzB,KAAK;EAAA,OAAKA,KAAK,YAAYzC,IAAI;AAAA;;AAE/C;AACA;AACA;AACA;AACA,IAAMkB,kBAAkB,GAAG,SAArBA,kBAAkB,CAAIF,KAAK,EAAK;EACpC,OAAOiD,YAAY,CAACjD,KAAK,EAAEkD,MAAM,EAAEC,UAAU,EAAE,IAAIC,GAAG,EAAE,EAAE,EAAE,CAAC;AAC/D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMhB,OAAO,GAAG,SAAVA,OAAO,CAAIpC,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEjB,KAAK,EAAK;EAC7C,qBAAmBM,YAAY,CAACjD,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEjB,KAAK,EAAE,EAAE,CAAC;IAAA;IAA9CkB,MAAM;EACf,OAAOA,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMZ,YAAY,GAAG,SAAfA,YAAY,CAAIjD,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEjB,KAAK,EAAE5B,IAAI;EAAA,OAC5C4C,CAAC,CAAC3D,KAAK,EAAE2C,KAAK,EAAE5B,IAAI,CAAC,GACjB6C,CAAC,CAACjB,KAAK,EAAE3C,KAAK,EAAEe,IAAI,CAAC,GACrB+C,KAAK,CAACC,OAAO,CAAC/D,KAAK,CAAC,GACpBgE,YAAY,CAAChE,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEjB,KAAK,EAAE5B,IAAI,CAAC,GACtC8B,QAAQ,CAAC7C,KAAK,CAAC,GACfiE,aAAa,CAACjE,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEjB,KAAK,EAAE5B,IAAI,CAAC,GACvC,CAAC4B,KAAK,EAAE,kBAAoB3C,KAAK,CAAE;AAAA;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMiE,aAAa,GAAG,SAAhBA,aAAa,CAAIjE,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEM,IAAI,EAAEnD,IAAI,EAAK;EACjD,IAAI4B,KAAK,GAAGuB,IAAI;EAChB,IAAML,MAAM,GACV,gEAAkE,CAAC,CAAE;EACvE,mCAA2BnE,MAAM,CAACe,OAAO,CAACT,KAAK,CAAC,qCAAE;IAA7C;MAAOmE,GAAG;MAAE1C,KAAK;IACpB,qBAAoBwB,YAAY,CAACxB,KAAK,EAAEkC,CAAC,EAAEC,CAAC,EAAEjB,KAAK,+BAAM5B,IAAI,IAAEoD,GAAG,GAAE;MAAA;MAA7DC,IAAI;MAAEC,GAAG;IAChB;IACAR,MAAM,CAACM,GAAG,CAAC,GAAGE,GAAG;IACjB1B,KAAK,GAAGyB,IAAI;EACd;EACA,OAAO,CAACzB,KAAK,EAAEkB,MAAM,CAAC;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMG,YAAY,GAAG,SAAfA,YAAY,CAAIhE,KAAK,EAAE2D,CAAC,EAAEC,CAAC,EAAEM,IAAI,EAAEnD,IAAI,EAAK;EAChD,IAAM8C,MAAM,GAAG,wBAA0B,EAAG;EAE5C,IAAIlB,KAAK,GAAGuB,IAAI;EAAA,4CACelE,KAAK,CAACS,OAAO,EAAE;IAAA;EAAA;IAA9C,uDAAgD;MAAA;QAApC6D,KAAK;QAAEC,OAAO;MACxB,qBAAoBtB,YAAY,CAACsB,OAAO,EAAEZ,CAAC,EAAEC,CAAC,EAAEjB,KAAK,+BAAM5B,IAAI,IAAEuD,KAAK,GAAE;QAAA;QAAjEF,IAAI;QAAEC,GAAG;MAChBR,MAAM,CAACS,KAAK,CAAC,GAAGD,GAAG;MACnB1B,KAAK,GAAGyB,IAAI;IACd;EAAC;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,CACLzB,KAAK,EACL,gEAAkEkB,MAAM,CACzE;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMvC,KAAK,GAAG,SAARA,KAAK,CAAIkD,MAAM,EAAEzD,IAAI,EAAEU,KAAK,EAAK;EACrC,IAAMgD,CAAC,GAAG1D,IAAI,CAAC2D,MAAM,GAAG,CAAC;EACzB,IAAIC,MAAM,GAAGH,MAAM;EAAA,4CACMzD,IAAI,CAACN,OAAO,EAAE;IAAA;EAAA;IAAvC,uDAAyC;MAAA;QAA/B6D,KAAK;QAAEH,GAAG;MAClB,IAAIG,KAAK,KAAKG,CAAC,EAAE;QACfE,MAAM,CAACR,GAAG,CAAC,GAAG1C,KAAK;MACrB,CAAC,MAAM;QACLkD,MAAM,GAAGA,MAAM,CAACR,GAAG,CAAC;MACtB;IACF;EAAC;IAAA;EAAA;IAAA;EAAA;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}