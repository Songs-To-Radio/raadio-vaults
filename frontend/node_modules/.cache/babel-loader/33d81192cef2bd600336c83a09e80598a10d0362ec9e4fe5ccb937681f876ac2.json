{"ast":null,"code":"import _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _awaitAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\nfunction rabinChunker(_x, _x2) {\n  return _rabinChunker.apply(this, arguments);\n}\nfunction _rabinChunker() {\n  _rabinChunker = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source, options) {\n    var min, max, avg, sizepow, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(options.minChunkSize && options.maxChunkSize && options.avgChunkSize)) {\n              _context.next = 6;\n              break;\n            }\n            avg = options.avgChunkSize;\n            min = options.minChunkSize;\n            max = options.maxChunkSize;\n            _context.next = 13;\n            break;\n          case 6:\n            if (options.avgChunkSize) {\n              _context.next = 10;\n              break;\n            }\n            throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n          case 10:\n            avg = options.avgChunkSize;\n            min = avg / 3;\n            max = avg + avg / 2;\n          case 13:\n            if (!(min < 16)) {\n              _context.next = 15;\n              break;\n            }\n            throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n          case 15:\n            if (max < min) {\n              max = min;\n            }\n            if (avg < min) {\n              avg = min;\n            }\n            sizepow = Math.floor(Math.log2(avg));\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 20;\n            _iterator = _asyncIterator(rabin(source, {\n              min: min,\n              max: max,\n              bits: sizepow,\n              window: options.window,\n              polynomial: options.polynomial\n            }));\n          case 22:\n            _context.next = 24;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 24:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 31;\n              break;\n            }\n            chunk = _step.value;\n            _context.next = 28;\n            return chunk;\n          case 28:\n            _iteratorAbruptCompletion = false;\n            _context.next = 22;\n            break;\n          case 31:\n            _context.next = 37;\n            break;\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 37:\n            _context.prev = 37;\n            _context.prev = 38;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 42;\n              break;\n            }\n            _context.next = 42;\n            return _awaitAsyncGenerator(_iterator.return());\n          case 42:\n            _context.prev = 42;\n            if (!_didIteratorError) {\n              _context.next = 45;\n              break;\n            }\n            throw _iteratorError;\n          case 45:\n            return _context.finish(42);\n          case 46:\n            return _context.finish(37);\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[20, 33, 37, 47], [38,, 42, 46]]);\n  }));\n  return _rabinChunker.apply(this, arguments);\n}\nexport default rabinChunker;\nfunction rabin(_x3, _x4) {\n  return _rabin.apply(this, arguments);\n}\nfunction _rabin() {\n  _rabin = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source, options) {\n    var r, buffers, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, sizes, i, size, buf;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _awaitAsyncGenerator(create(options.bits, options.min, options.max, options.window));\n          case 2:\n            r = _context2.sent;\n            buffers = new BufferList();\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context2.prev = 6;\n            _iterator2 = _asyncIterator(source);\n          case 8:\n            _context2.next = 10;\n            return _awaitAsyncGenerator(_iterator2.next());\n          case 10:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n              _context2.next = 27;\n              break;\n            }\n            chunk = _step2.value;\n            buffers.append(chunk);\n            sizes = r.fingerprint(chunk);\n            i = 0;\n          case 15:\n            if (!(i < sizes.length)) {\n              _context2.next = 24;\n              break;\n            }\n            size = sizes[i];\n            buf = buffers.slice(0, size);\n            buffers.consume(size);\n            _context2.next = 21;\n            return buf;\n          case 21:\n            i++;\n            _context2.next = 15;\n            break;\n          case 24:\n            _iteratorAbruptCompletion2 = false;\n            _context2.next = 8;\n            break;\n          case 27:\n            _context2.next = 33;\n            break;\n          case 29:\n            _context2.prev = 29;\n            _context2.t0 = _context2[\"catch\"](6);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context2.t0;\n          case 33:\n            _context2.prev = 33;\n            _context2.prev = 34;\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context2.next = 38;\n              break;\n            }\n            _context2.next = 38;\n            return _awaitAsyncGenerator(_iterator2.return());\n          case 38:\n            _context2.prev = 38;\n            if (!_didIteratorError2) {\n              _context2.next = 41;\n              break;\n            }\n            throw _iteratorError2;\n          case 41:\n            return _context2.finish(38);\n          case 42:\n            return _context2.finish(33);\n          case 43:\n            if (!buffers.length) {\n              _context2.next = 46;\n              break;\n            }\n            _context2.next = 46;\n            return buffers.slice(0);\n          case 46:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[6, 29, 33, 43], [34,, 38, 42]]);\n  }));\n  return _rabin.apply(this, arguments);\n}","map":{"version":3,"names":["BufferList","create","errcode","rabinChunker","source","options","minChunkSize","maxChunkSize","avgChunkSize","avg","min","max","Error","sizepow","Math","floor","log2","rabin","bits","window","polynomial","chunk","r","buffers","append","sizes","fingerprint","i","length","size","buf","slice","consume"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js"],"sourcesContent":["import BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\nasync function* rabinChunker(source, options) {\n  let min, max, avg;\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  }\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n  if (max < min) {\n    max = min;\n  }\n  if (avg < min) {\n    avg = min;\n  }\n  const sizepow = Math.floor(Math.log2(avg));\n  for await (const chunk of rabin(source, {\n      min: min,\n      max: max,\n      bits: sizepow,\n      window: options.window,\n      polynomial: options.polynomial\n    })) {\n    yield chunk;\n  }\n}\nexport default rabinChunker;\nasync function* rabin(source, options) {\n  const r = await create(options.bits, options.min, options.max, options.window);\n  const buffers = new BufferList();\n  for await (const chunk of source) {\n    buffers.append(chunk);\n    const sizes = r.fingerprint(chunk);\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i];\n      const buf = buffers.slice(0, size);\n      buffers.consume(size);\n      yield buf;\n    }\n  }\n  if (buffers.length) {\n    yield buffers.slice(0);\n  }\n}"],"mappings":";;;;AAAA,OAAOA,UAAU,MAAM,kBAAkB;AACzC,SAASC,MAAM,QAAQ,YAAY;AACnC,OAAOC,OAAO,MAAM,UAAU;AAAC,SACfC,YAAY;EAAA;AAAA;AAAA;EAAA,6EAA5B,iBAA6BC,MAAM,EAAEC,OAAO;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,MAEtCA,OAAO,CAACC,YAAY,IAAID,OAAO,CAACE,YAAY,IAAIF,OAAO,CAACG,YAAY;cAAA;cAAA;YAAA;YACtEC,GAAG,GAAGJ,OAAO,CAACG,YAAY;YAC1BE,GAAG,GAAGL,OAAO,CAACC,YAAY;YAC1BK,GAAG,GAAGN,OAAO,CAACE,YAAY;YAAC;YAAA;UAAA;YAAA,IACjBF,OAAO,CAACG,YAAY;cAAA;cAAA;YAAA;YAAA,MACxBN,OAAO,CAAC,IAAIU,KAAK,CAAC,sCAAsC,CAAC,EAAE,4BAA4B,CAAC;UAAA;YAE9FH,GAAG,GAAGJ,OAAO,CAACG,YAAY;YAC1BE,GAAG,GAAGD,GAAG,GAAG,CAAC;YACbE,GAAG,GAAGF,GAAG,GAAGA,GAAG,GAAG,CAAC;UAAC;YAAA,MAElBC,GAAG,GAAG,EAAE;cAAA;cAAA;YAAA;YAAA,MACJR,OAAO,CAAC,IAAIU,KAAK,CAAC,mCAAmC,CAAC,EAAE,4BAA4B,CAAC;UAAA;YAE7F,IAAID,GAAG,GAAGD,GAAG,EAAE;cACbC,GAAG,GAAGD,GAAG;YACX;YACA,IAAID,GAAG,GAAGC,GAAG,EAAE;cACbD,GAAG,GAAGC,GAAG;YACX;YACMG,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,IAAI,CAACP,GAAG,CAAC,CAAC;YAAA;YAAA;YAAA;YAAA,2BAChBQ,KAAK,CAACb,MAAM,EAAE;cACpCM,GAAG,EAAEA,GAAG;cACRC,GAAG,EAAEA,GAAG;cACRO,IAAI,EAAEL,OAAO;cACbM,MAAM,EAAEd,OAAO,CAACc,MAAM;cACtBC,UAAU,EAAEf,OAAO,CAACe;YACtB,CAAC,CAAC;UAAA;YAAA;YAAA;UAAA;YAAA;cAAA;cAAA;YAAA;YANaC,KAAK;YAAA;YAOpB,OAAMA,KAAK;UAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEd;EAAA;AAAA;AACD,eAAelB,YAAY;AAAC,SACZc,KAAK;EAAA;AAAA;AAAA;EAAA,sEAArB,kBAAsBb,MAAM,EAAEC,OAAO;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,4BACnBJ,MAAM,CAACI,OAAO,CAACa,IAAI,EAAEb,OAAO,CAACK,GAAG,EAAEL,OAAO,CAACM,GAAG,EAAEN,OAAO,CAACc,MAAM,CAAC;UAAA;YAAxEG,CAAC;YACDC,OAAO,GAAG,IAAIvB,UAAU,EAAE;YAAA;YAAA;YAAA;YAAA,4BACNI,MAAM;UAAA;YAAA;YAAA;UAAA;YAAA;cAAA;cAAA;YAAA;YAAfiB,KAAK;YACpBE,OAAO,CAACC,MAAM,CAACH,KAAK,CAAC;YACfI,KAAK,GAAGH,CAAC,CAACI,WAAW,CAACL,KAAK,CAAC;YACzBM,CAAC,GAAG,CAAC;UAAA;YAAA,MAAEA,CAAC,GAAGF,KAAK,CAACG,MAAM;cAAA;cAAA;YAAA;YACxBC,IAAI,GAAGJ,KAAK,CAACE,CAAC,CAAC;YACfG,GAAG,GAAGP,OAAO,CAACQ,KAAK,CAAC,CAAC,EAAEF,IAAI,CAAC;YAClCN,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC;YAAC;YACtB,OAAMC,GAAG;UAAA;YAJuBH,CAAC,EAAE;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA;UAAA;YAAA,KAOnCJ,OAAO,CAACK,MAAM;cAAA;cAAA;YAAA;YAAA;YAChB,OAAML,OAAO,CAACQ,KAAK,CAAC,CAAC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEzB;EAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}