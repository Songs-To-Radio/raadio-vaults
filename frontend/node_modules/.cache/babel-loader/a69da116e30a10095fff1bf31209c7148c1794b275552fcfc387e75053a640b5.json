{"ast":null,"code":"import { NFTStorage, File } from \"nft.storage\";\nimport axios from \"axios\";\nimport { v4 } from \"uuid\";\nexport const endPoint = \"http://localhost:2000\";\nexport const nftStorageEndPoint = \"https://nftstorage.link/ipfs\";\nasync function uploadToServer(ipfsUrl, wallet_address, title) {\n  try {\n    let res = await fetch(`${endPoint}/create-vault`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        controller: wallet_address,\n        ipfsUrl,\n        mediaTitle: title\n      }),\n      headers: {\n        \"content-type\": \"application/json\"\n      }\n    });\n    return res.status;\n  } catch (error) {\n    throw error;\n  }\n}\nconst API_KEY = process.env.NFT_STORAGE_API_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweGE5M0I4NGFlNThkMDNkOTAwQjc5MzExOGEzNDQ2ZEZCZUU5NTVERmEiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY1MTUxMDYyMDg2MCwibmFtZSI6IlNUUiAtIE1hcmtldHBsYWNlICJ9.D71kmGtnh1wOLBF2BfVqMtuCPk79wvEiFxuhpuKgqwA\";\nconst client = new NFTStorage({\n  token: API_KEY\n});\nexport async function uploadToIpfsAndServer(image, name, description, wallet_address, web2) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n    const baseURI = await client.store({\n      name,\n      video: content,\n      image: content,\n      description,\n      description,\n      collection: name,\n      web2_metadata: web2\n    });\n    console.log(baseURI);\n    return await uploadToServer(baseURI.url, wallet_address, name);\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function getVaults(address) {\n  try {\n    let res = await fetch(`${endPoint}/get-vaults/${address}`);\n    // if(res.status != 200 || res.status != 201) throw(res);\n    res = await res.json();\n    return res;\n  } catch (error) {\n    throw error;\n  }\n}\nexport function parseUrl(link, neg) {\n  link = link.replace(\"ipfs://\", \"\");\n  if (neg) return link;\n  return nftStorageEndPoint + \"/\" + link;\n}\nexport async function getMetadata(link, id) {\n  try {\n    link = link.replace(\"ipfs://\", \"\");\n    link = nftStorageEndPoint + \"/\" + link;\n    let res = await axios(link);\n    let res2;\n    if (id) {\n      res2 = await axios(`${endPoint}/metadata/${id}`);\n    }\n    return id ? res2.data : res.data;\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function getUser(addr) {\n  try {\n    let res = await axios(`${endPoint}/get-user/${addr}`);\n    if (res.status != 200) {\n      throw \"error\";\n    }\n    return res.data;\n  } catch (error) {\n    throw error;\n  }\n}\nexport async function saveWhiteList(whitelist, addr) {\n  try {\n    let res = await fetch(`${endPoint}/edit-user/${addr}`, {\n      method: \"POST\",\n      body: JSON.stringify(whitelist),\n      headers: {\n        \"content-type\": \"application/json\"\n      }\n    });\n    if (res.status != 200) throw \"error\";\n    return await res.json();\n  } catch (error) {\n    throw error;\n  }\n}","map":{"version":3,"names":["NFTStorage","File","axios","v4","endPoint","nftStorageEndPoint","uploadToServer","ipfsUrl","wallet_address","title","res","fetch","method","body","JSON","stringify","controller","mediaTitle","headers","status","error","API_KEY","process","env","NFT_STORAGE_API_KEY","client","token","uploadToIpfsAndServer","image","name","description","web2","url","URL","createObjectURL","blob","content","type","split","baseURI","store","video","collection","web2_metadata","console","log","getVaults","address","json","parseUrl","link","neg","replace","getMetadata","id","res2","data","getUser","addr","saveWhiteList","whitelist"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/src/api/api.js"],"sourcesContent":["import { NFTStorage, File, } from \"nft.storage\";\nimport axios from \"axios\";\nimport { v4 } from \"uuid\";\n\nexport const endPoint = \"http://localhost:2000\";\nexport const nftStorageEndPoint = \"https://nftstorage.link/ipfs\";\n\nasync function uploadToServer(ipfsUrl, wallet_address, title) {\n  try {\n    let res = await fetch(`${endPoint}/create-vault`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        controller: wallet_address,\n        ipfsUrl,\n        mediaTitle: title,\n      }),\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n\n    return res.status;\n  } catch (error) {\n    throw error;\n  }\n}\n\nconst API_KEY =\n  process.env.NFT_STORAGE_API_KEY ||\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweGE5M0I4NGFlNThkMDNkOTAwQjc5MzExOGEzNDQ2ZEZCZUU5NTVERmEiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY1MTUxMDYyMDg2MCwibmFtZSI6IlNUUiAtIE1hcmtldHBsYWNlICJ9.D71kmGtnh1wOLBF2BfVqMtuCPk79wvEiFxuhpuKgqwA\";\nconst client = new NFTStorage({ token: API_KEY });\n\nexport async function uploadToIpfsAndServer(\n  image,\n  name,\n  description,\n  wallet_address,\n  web2\n) {\n  try {\n    let url = URL.createObjectURL(image);\n    let res = await fetch(url);\n    let blob = await res.blob();\n    const content = new File([image], v4() + \".\" + blob.type.split(\"/\")[1]);\n\n    const baseURI = await client.store({\n      name,\n      video: content,\n      image: content,\n      description,\n      description,\n      collection: name,\n      web2_metadata: web2,\n    });\n    console.log(baseURI);\n    return await uploadToServer(baseURI.url, wallet_address, name);\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport async function getVaults(address) {\n  try {\n    let res = await fetch(`${endPoint}/get-vaults/${address}`);\n    // if(res.status != 200 || res.status != 201) throw(res);\n    res = await res.json();\n    return res;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport function parseUrl(link, neg) {\n  link = link.replace(\"ipfs://\", \"\");\n  if (neg) return link;\n  return nftStorageEndPoint + \"/\" + link;\n}\n\nexport async function getMetadata(link, id) {\n  try {\n    link = link.replace(\"ipfs://\", \"\");\n    link = nftStorageEndPoint + \"/\" + link;\n    let res = await axios(link);\n    let res2;\n    if (id) {\n      res2 = await axios(`${endPoint}/metadata/${id}`);\n    }\n    return id ? res2.data : res.data;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport async function getUser(addr) {\n  try {\n    let res = await axios(`${endPoint}/get-user/${addr}`);\n    if (res.status != 200) {\n      throw \"error\";\n    }\n    return res.data;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport async function saveWhiteList(whitelist, addr) {\n  try {\n    let res = await fetch(`${endPoint}/edit-user/${addr}`, {\n      method: \"POST\",\n      body: JSON.stringify(whitelist),\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n    if(res.status != 200) throw(\"error\");\n    return await res.json();\n  } catch (error) {\n    throw error;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}