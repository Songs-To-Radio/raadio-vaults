{"ast":null,"code":"import _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\nfunction addToTree(_x6, _x7, _x8) {\n  return _addToTree.apply(this, arguments);\n}\nfunction _addToTree() {\n  _addToTree = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(elem, tree, options) {\n    var pathElems, lastIndex, parent, currentPath, i, pathElem, last, dir;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            pathElems = toPathComponents(elem.path || '');\n            lastIndex = pathElems.length - 1;\n            parent = tree;\n            currentPath = '';\n            i = 0;\n          case 5:\n            if (!(i < pathElems.length)) {\n              _context3.next = 30;\n              break;\n            }\n            pathElem = pathElems[i];\n            currentPath += \"\".concat(currentPath ? '/' : '').concat(pathElem);\n            last = i === lastIndex;\n            parent.dirty = true;\n            parent.cid = undefined;\n            parent.size = undefined;\n            if (!last) {\n              _context3.next = 20;\n              break;\n            }\n            _context3.next = 15;\n            return parent.put(pathElem, elem);\n          case 15:\n            _context3.next = 17;\n            return flatToShard(null, parent, options.shardSplitThreshold, options);\n          case 17:\n            tree = _context3.sent;\n            _context3.next = 27;\n            break;\n          case 20:\n            _context3.next = 22;\n            return parent.get(pathElem);\n          case 22:\n            dir = _context3.sent;\n            if (!dir || !(dir instanceof Dir)) {\n              dir = new DirFlat({\n                root: false,\n                dir: true,\n                parent: parent,\n                parentKey: pathElem,\n                path: currentPath,\n                dirty: true,\n                flat: true,\n                mtime: dir && dir.unixfs && dir.unixfs.mtime,\n                mode: dir && dir.unixfs && dir.unixfs.mode\n              }, options);\n            }\n            _context3.next = 26;\n            return parent.put(pathElem, dir);\n          case 26:\n            parent = dir;\n          case 27:\n            i++;\n            _context3.next = 5;\n            break;\n          case 30:\n            return _context3.abrupt(\"return\", tree);\n          case 31:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _addToTree.apply(this, arguments);\n}\nfunction flushAndYield(_x, _x2) {\n  return _flushAndYield.apply(this, arguments);\n}\nfunction _flushAndYield() {\n  _flushAndYield = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tree, blockstore) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (tree instanceof Dir) {\n              _context.next = 5;\n              break;\n            }\n            if (!(tree && tree.unixfs && tree.unixfs.isDirectory())) {\n              _context.next = 4;\n              break;\n            }\n            _context.next = 4;\n            return tree;\n          case 4:\n            return _context.abrupt(\"return\");\n          case 5:\n            return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(tree.flush(blockstore)), _awaitAsyncGenerator), \"t0\", 6);\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _flushAndYield.apply(this, arguments);\n}\nfunction treeBuilder(_x3, _x4, _x5) {\n  return _treeBuilder.apply(this, arguments);\n}\nfunction _treeBuilder() {\n  _treeBuilder = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source, block, options) {\n    var tree, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, unwrapped;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            tree = new DirFlat({\n              root: true,\n              dir: true,\n              path: '',\n              dirty: true,\n              flat: true\n            }, options);\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.prev = 3;\n            _iterator = _asyncIterator(source);\n          case 5:\n            _context2.next = 7;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 7:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n              _context2.next = 20;\n              break;\n            }\n            entry = _step.value;\n            if (entry) {\n              _context2.next = 11;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 17);\n          case 11:\n            _context2.next = 13;\n            return _awaitAsyncGenerator(addToTree(entry, tree, options));\n          case 13:\n            tree = _context2.sent;\n            if (!(!entry.unixfs || !entry.unixfs.isDirectory())) {\n              _context2.next = 17;\n              break;\n            }\n            _context2.next = 17;\n            return entry;\n          case 17:\n            _iteratorAbruptCompletion = false;\n            _context2.next = 5;\n            break;\n          case 20:\n            _context2.next = 26;\n            break;\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](3);\n            _didIteratorError = true;\n            _iteratorError = _context2.t0;\n          case 26:\n            _context2.prev = 26;\n            _context2.prev = 27;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.next = 31;\n              break;\n            }\n            _context2.next = 31;\n            return _awaitAsyncGenerator(_iterator.return());\n          case 31:\n            _context2.prev = 31;\n            if (!_didIteratorError) {\n              _context2.next = 34;\n              break;\n            }\n            throw _iteratorError;\n          case 34:\n            return _context2.finish(31);\n          case 35:\n            return _context2.finish(26);\n          case 36:\n            if (!options.wrapWithDirectory) {\n              _context2.next = 40;\n              break;\n            }\n            return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(flushAndYield(tree, block)), _awaitAsyncGenerator), \"t1\", 38);\n          case 38:\n            _context2.next = 70;\n            break;\n          case 40:\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context2.prev = 42;\n            _iterator2 = _asyncIterator(tree.eachChildSeries());\n          case 44:\n            _context2.next = 46;\n            return _awaitAsyncGenerator(_iterator2.next());\n          case 46:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n              _context2.next = 54;\n              break;\n            }\n            unwrapped = _step2.value;\n            if (unwrapped) {\n              _context2.next = 50;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 51);\n          case 50:\n            return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(flushAndYield(unwrapped.child, block)), _awaitAsyncGenerator), \"t2\", 51);\n          case 51:\n            _iteratorAbruptCompletion2 = false;\n            _context2.next = 44;\n            break;\n          case 54:\n            _context2.next = 60;\n            break;\n          case 56:\n            _context2.prev = 56;\n            _context2.t3 = _context2[\"catch\"](42);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context2.t3;\n          case 60:\n            _context2.prev = 60;\n            _context2.prev = 61;\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context2.next = 65;\n              break;\n            }\n            _context2.next = 65;\n            return _awaitAsyncGenerator(_iterator2.return());\n          case 65:\n            _context2.prev = 65;\n            if (!_didIteratorError2) {\n              _context2.next = 68;\n              break;\n            }\n            throw _iteratorError2;\n          case 68:\n            return _context2.finish(65);\n          case 69:\n            return _context2.finish(60);\n          case 70:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 22, 26, 36], [27,, 31, 35], [42, 56, 60, 70], [61,, 65, 69]]);\n  }));\n  return _treeBuilder.apply(this, arguments);\n}\nexport default treeBuilder;","map":{"version":3,"names":["DirFlat","flatToShard","Dir","toPathComponents","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","undefined","size","put","shardSplitThreshold","get","dir","root","parentKey","flat","mtime","unixfs","mode","flushAndYield","blockstore","isDirectory","flush","treeBuilder","source","block","entry","wrapWithDirectory","eachChildSeries","unwrapped","child"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js"],"sourcesContent":["import DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${ currentPath ? '/' : '' }${ pathElem }`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n  return tree;\n}\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n    return;\n  }\n  yield* tree.flush(blockstore);\n}\nasync function* treeBuilder(source, block, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n    tree = await addToTree(entry, tree, options);\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\nexport default treeBuilder;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}