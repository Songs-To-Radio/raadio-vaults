{"ast":null,"code":"'use strict';\n\n// @ts-ignore\nvar _createForOfIteratorHelper = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar SparseArray = require('sparse-array');\nvar _require = require('uint8arrays/from-string'),\n  uint8ArrayFromString = _require.fromString;\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nvar Bucket = /*#__PURE__*/function () {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  function Bucket(options, parent) {\n    var posAtParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Bucket);\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray();\n\n    /** @type {string | null} */\n    this.key = null;\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  _createClass(Bucket, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value) {\n        var place;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._findNewBucketAndPos(key);\n              case 2:\n                place = _context.sent;\n                _context.next = 5;\n                return place.bucket._putAt(place, key, value);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n    /**\n     * @param {string} key\n     */\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        var child;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._findChild(key);\n              case 2:\n                child = _context2.sent;\n                if (!child) {\n                  _context2.next = 5;\n                  break;\n                }\n                return _context2.abrupt(\"return\", child.value);\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * @param {string} key\n     */\n  }, {\n    key: \"del\",\n    value: function () {\n      var _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n        var place, child;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._findPlace(key);\n              case 2:\n                place = _context3.sent;\n                child = place.bucket._at(place.pos);\n                if (child && child.key === key) {\n                  place.bucket._delAt(place.pos);\n                }\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function del(_x4) {\n        return _del.apply(this, arguments);\n      }\n      return del;\n    }()\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"leafCount\",\n    value: function leafCount() {\n      var children = this._children.compactArray();\n      return children.reduce(function (acc, child) {\n        if (child instanceof Bucket) {\n          return acc + child.leafCount();\n        }\n        return acc + 1;\n      }, 0);\n    }\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"onlyChild\",\n    value: function onlyChild() {\n      return this._children.get(0);\n    }\n\n    /**\n     * @returns {Iterable<BucketChild<T>>}\n     */\n  }, {\n    key: \"eachLeafSeries\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function eachLeafSeries() {\n      var children, _iterator, _step, child;\n      return _regeneratorRuntime().wrap(function eachLeafSeries$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              children = this._children.compactArray();\n              _iterator = _createForOfIteratorHelper(children);\n              _context4.prev = 2;\n              _iterator.s();\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context4.next = 14;\n                break;\n              }\n              child = _step.value;\n              if (!(child instanceof Bucket)) {\n                _context4.next = 10;\n                break;\n              }\n              return _context4.delegateYield(child.eachLeafSeries(), \"t0\", 8);\n            case 8:\n              _context4.next = 12;\n              break;\n            case 10:\n              _context4.next = 12;\n              return child;\n            case 12:\n              _context4.next = 4;\n              break;\n            case 14:\n              _context4.next = 19;\n              break;\n            case 16:\n              _context4.prev = 16;\n              _context4.t1 = _context4[\"catch\"](2);\n              _iterator.e(_context4.t1);\n            case 19:\n              _context4.prev = 19;\n              _iterator.f();\n              return _context4.finish(19);\n            case 22:\n              return _context4.abrupt(\"return\", []);\n            case 23:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, eachLeafSeries, this, [[2, 16, 19, 22]]);\n    })\n    /**\n     * @param {(value: BucketChild<T>, index: number) => T} map\n     * @param {(reduced: any) => any} reduce\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(map, reduce) {\n      /** @type {T[]} */\n      var acc = [];\n      // serialize to a custom non-sparse representation\n      return reduce(this._children.reduce(function (acc, child, index) {\n        if (child) {\n          if (child instanceof Bucket) {\n            acc.push(child.serialize(map, reduce));\n          } else {\n            acc.push(map(child, index));\n          }\n        }\n        return acc;\n      }, acc));\n    }\n\n    /**\n     * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n     * @param {(reduced: any) => Promise<any>} asyncReduce\n     */\n  }, {\n    key: \"asyncTransform\",\n    value: function asyncTransform(asyncMap, asyncReduce) {\n      return asyncTransformBucket(this, asyncMap, asyncReduce);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.serialize(mapNode, reduceNodes);\n    }\n  }, {\n    key: \"prettyPrint\",\n    value: function prettyPrint() {\n      return JSON.stringify(this.toJSON(), null, '  ');\n    }\n  }, {\n    key: \"tableSize\",\n    value: function tableSize() {\n      return Math.pow(2, this._options.bits);\n    }\n\n    /**\n     * @param {string} key\n     * @returns {Promise<BucketChild<T> | undefined>}\n     */\n  }, {\n    key: \"_findChild\",\n    value: function () {\n      var _findChild2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {\n        var result, child;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._findPlace(key);\n              case 2:\n                result = _context5.sent;\n                child = result.bucket._at(result.pos);\n                if (!(child instanceof Bucket)) {\n                  _context5.next = 6;\n                  break;\n                }\n                return _context5.abrupt(\"return\", undefined);\n              case 6:\n                if (!(child && child.key === key)) {\n                  _context5.next = 8;\n                  break;\n                }\n                return _context5.abrupt(\"return\", child);\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function _findChild(_x5) {\n        return _findChild2.apply(this, arguments);\n      }\n      return _findChild;\n    }()\n    /**\n     * @param {string | InfiniteHash} key\n     * @returns {Promise<BucketPosition<T>>}\n     */\n  }, {\n    key: \"_findPlace\",\n    value: function () {\n      var _findPlace2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {\n        var hashValue, index, child;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n                _context6.next = 3;\n                return hashValue.take(this._options.bits);\n              case 3:\n                index = _context6.sent;\n                child = this._children.get(index);\n                if (!(child instanceof Bucket)) {\n                  _context6.next = 7;\n                  break;\n                }\n                return _context6.abrupt(\"return\", child._findPlace(hashValue));\n              case 7:\n                return _context6.abrupt(\"return\", {\n                  bucket: this,\n                  pos: index,\n                  hash: hashValue,\n                  existingChild: child\n                });\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _findPlace(_x6) {\n        return _findPlace2.apply(this, arguments);\n      }\n      return _findPlace;\n    }()\n    /**\n     * @param {string | InfiniteHash} key\n     * @returns {Promise<BucketPosition<T>>}\n     */\n  }, {\n    key: \"_findNewBucketAndPos\",\n    value: function () {\n      var _findNewBucketAndPos2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key) {\n        var place, bucket, newPlace;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._findPlace(key);\n              case 2:\n                place = _context7.sent;\n                if (!(place.existingChild && place.existingChild.key !== key)) {\n                  _context7.next = 11;\n                  break;\n                }\n                // conflict\n                bucket = new Bucket(this._options, place.bucket, place.pos);\n                place.bucket._putObjectAt(place.pos, bucket);\n\n                // put the previous value\n                _context7.next = 8;\n                return bucket._findPlace(place.existingChild.hash);\n              case 8:\n                newPlace = _context7.sent;\n                newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n                return _context7.abrupt(\"return\", bucket._findNewBucketAndPos(place.hash));\n              case 11:\n                return _context7.abrupt(\"return\", place);\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function _findNewBucketAndPos(_x7) {\n        return _findNewBucketAndPos2.apply(this, arguments);\n      }\n      return _findNewBucketAndPos;\n    }()\n    /**\n     * @param {BucketPosition<T>} place\n     * @param {string} key\n     * @param {T} value\n     */\n  }, {\n    key: \"_putAt\",\n    value: function _putAt(place, key, value) {\n      this._putObjectAt(place.pos, {\n        key: key,\n        value: value,\n        hash: place.hash\n      });\n    }\n\n    /**\n     * @param {number} pos\n     * @param {Bucket<T> | BucketChild<T>} object\n     */\n  }, {\n    key: \"_putObjectAt\",\n    value: function _putObjectAt(pos, object) {\n      if (!this._children.get(pos)) {\n        this._popCount++;\n      }\n      this._children.set(pos, object);\n    }\n\n    /**\n     * @param {number} pos\n     */\n  }, {\n    key: \"_delAt\",\n    value: function _delAt(pos) {\n      if (pos === -1) {\n        throw new Error('Invalid position');\n      }\n      if (this._children.get(pos)) {\n        this._popCount--;\n      }\n      this._children.unset(pos);\n      this._level();\n    }\n  }, {\n    key: \"_level\",\n    value: function _level() {\n      if (this._parent && this._popCount <= 1) {\n        if (this._popCount === 1) {\n          // remove myself from parent, replacing me with my only child\n          var onlyChild = this._children.find(exists);\n          if (onlyChild && !(onlyChild instanceof Bucket)) {\n            var hash = onlyChild.hash;\n            hash.untake(this._options.bits);\n            var place = {\n              pos: this._posAtParent,\n              hash: hash,\n              bucket: this._parent\n            };\n            this._parent._putAt(place, onlyChild.key, onlyChild.value);\n          }\n        } else {\n          this._parent._delAt(this._posAtParent);\n        }\n      }\n    }\n\n    /**\n     * @param {number} index\n     * @returns {BucketChild<T> | Bucket<T> | undefined}\n     */\n  }, {\n    key: \"_at\",\n    value: function _at(index) {\n      return this._children.get(index);\n    }\n  }]);\n  return Bucket;\n}();\n/**\n * @param {any} o\n */\nfunction exists(o) {\n  return Boolean(o);\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode(node, index) {\n  return node.key;\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nfunction asyncTransformBucket(_x8, _x9, _x10) {\n  return _asyncTransformBucket.apply(this, arguments);\n}\nfunction _asyncTransformBucket() {\n  _asyncTransformBucket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(bucket, asyncMap, asyncReduce) {\n    var output, _iterator2, _step2, child, mappedChildren;\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            output = [];\n            _iterator2 = _createForOfIteratorHelper(bucket._children.compactArray());\n            _context8.prev = 2;\n            _iterator2.s();\n          case 4:\n            if ((_step2 = _iterator2.n()).done) {\n              _context8.next = 17;\n              break;\n            }\n            child = _step2.value;\n            if (!(child instanceof Bucket)) {\n              _context8.next = 11;\n              break;\n            }\n            _context8.next = 9;\n            return asyncTransformBucket(child, asyncMap, asyncReduce);\n          case 9:\n            _context8.next = 15;\n            break;\n          case 11:\n            _context8.next = 13;\n            return asyncMap(child);\n          case 13:\n            mappedChildren = _context8.sent;\n            output.push({\n              bitField: bucket._children.bitField(),\n              children: mappedChildren\n            });\n          case 15:\n            _context8.next = 4;\n            break;\n          case 17:\n            _context8.next = 22;\n            break;\n          case 19:\n            _context8.prev = 19;\n            _context8.t0 = _context8[\"catch\"](2);\n            _iterator2.e(_context8.t0);\n          case 22:\n            _context8.prev = 22;\n            _iterator2.f();\n            return _context8.finish(22);\n          case 25:\n            return _context8.abrupt(\"return\", asyncReduce(output));\n          case 26:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[2, 19, 22, 25]]);\n  }));\n  return _asyncTransformBucket.apply(this, arguments);\n}\nmodule.exports = Bucket;","map":{"version":3,"names":["SparseArray","require","uint8ArrayFromString","fromString","Bucket","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","value","_findNewBucketAndPos","place","bucket","_putAt","_findChild","child","_findPlace","_at","pos","_delAt","children","compactArray","reduce","acc","leafCount","length","get","eachLeafSeries","map","index","push","serialize","asyncMap","asyncReduce","asyncTransformBucket","mapNode","reduceNodes","JSON","stringify","toJSON","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","onlyChild","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/hamt-sharding/src/bucket.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}