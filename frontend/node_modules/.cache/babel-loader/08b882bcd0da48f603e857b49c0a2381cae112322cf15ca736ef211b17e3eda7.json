{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectWithoutProperties from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _awaitAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar _excluded = [\"endpoint\", \"rateLimiter\"],\n  _excluded2 = [\"endpoint\", \"rateLimiter\"],\n  _excluded3 = [\"endpoint\", \"rateLimiter\"];\n/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables';\nimport pRetry, { AbortError } from 'p-retry';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport throttledQueue from 'throttled-queue';\nimport * as Token from './token.js';\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\nimport pipe from 'it-pipe';\nvar MAX_STORE_RETRIES = 5;\nvar MAX_CONCURRENT_UPLOADS = 3;\nvar MAX_CHUNK_SIZE = 1024 * 1024 * 10; // chunk to ~10MB CARs\nvar RATE_LIMIT_REQUESTS = 30;\nvar RATE_LIMIT_PERIOD = 10 * 1000;\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  var throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);\n  return function () {\n    return throttle(function () {});\n  };\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nvar globalRateLimiter = createRateLimiter();\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nvar NFTStorage = /*#__PURE__*/function () {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  function NFTStorage(_ref3) {\n    var token = _ref3.token,\n      did = _ref3.did,\n      _ref3$endpoint = _ref3.endpoint,\n      endpoint = _ref3$endpoint === void 0 ? new URL('https://api.nft.storage') : _ref3$endpoint,\n      rateLimiter = _ref3.rateLimiter;\n    _classCallCheck(this, NFTStorage);\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint;\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter();\n\n    /**\n     * @readonly\n     */\n    this.did = did;\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  _createClass(NFTStorage, [{\n    key: \"storeBlob\",\n    value:\n    // Just a sugar so you don't have to pass around endpoint and token around.\n\n    /**\n     * Stores a single file and returns the corresponding Content Identifier (CID).\n     * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n     * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n     * that no file name or file metadata is retained.\n     *\n     * @example\n     * ```js\n     * const content = new Blob(['hello world'])\n     * const cid = await client.storeBlob(content)\n     * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n     * ```\n     *\n     * @param {Blob} blob\n     * @param {RequestOptions} [options]\n     */\n    function storeBlob(blob, options) {\n      return NFTStorage.storeBlob(this, blob, options);\n    }\n\n    /**\n     * Stores files encoded as a single [Content Addressed Archive\n     * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n     *\n     * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n     * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n     *\n     * Returns the corresponding Content Identifier (CID).\n     *\n     * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n     * details on packing a CAR file.\n     *\n     * @example\n     * ```js\n     * import { pack } from 'ipfs-car/pack'\n     * import { CarReader } from '@ipld/car'\n     * const { out, root } = await pack({\n     *  input: fs.createReadStream('pinpie.pdf')\n     * })\n     * const expectedCid = root.toString()\n     * const carReader = await CarReader.fromIterable(out)\n     * const cid = await storage.storeCar(carReader)\n     * console.assert(cid === expectedCid)\n     * ```\n     *\n     * @example\n     * ```\n     * import { packToBlob } from 'ipfs-car/pack/blob'\n     * const data = 'Hello world'\n     * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n     * const expectedCid = root.toString()\n     * const cid = await client.storeCar(car)\n     * console.assert(cid === expectedCid)\n     * ```\n     * @param {Blob|CarReader} car\n     * @param {import('./lib/interface.js').CarStorerOptions} [options]\n     */\n  }, {\n    key: \"storeCar\",\n    value: function storeCar(car, options) {\n      return NFTStorage.storeCar(this, car, options);\n    }\n\n    /**\n     * Stores a directory of files and returns a CID for the directory.\n     *\n     * @example\n     * ```js\n     * const cid = await client.storeDirectory([\n     *   new File(['hello world'], 'hello.txt'),\n     *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n     * ])\n     * cid //>\n     * ```\n     *\n     * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n     * instance as well, in which case directory structure will be retained.\n     *\n     * @param {FilesSource} files\n     * @param {RequestOptions} [options]\n     */\n  }, {\n    key: \"storeDirectory\",\n    value: function storeDirectory(files, options) {\n      return NFTStorage.storeDirectory(this, files, options);\n    }\n\n    /**\n     * Returns current status of the stored NFT by its CID. Note the NFT must\n     * have previously been stored by this account.\n     *\n     * @example\n     * ```js\n     * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n     * ```\n     *\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     */\n  }, {\n    key: \"status\",\n    value: function status(cid, options) {\n      return NFTStorage.status(this, cid, options);\n    }\n\n    /**\n     * Removes stored content by its CID from the service.\n     *\n     * > Please note that even if content is removed from the service other nodes\n     * that have replicated it might still continue providing it.\n     *\n     * @example\n     * ```js\n     * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n     * ```\n     *\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(cid, options) {\n      return NFTStorage.delete(this, cid, options);\n    }\n\n    /**\n     * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n     * was not found.\n     *\n     * @example\n     * ```js\n     * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n     * ```\n     *\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     */\n  }, {\n    key: \"check\",\n    value: function check(cid, options) {\n      return NFTStorage.check(this, cid, options);\n    }\n\n    /**\n     * Stores the given token and all resources it references (in the form of a\n     * File or a Blob) along with a metadata JSON as specificed in\n     * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n     * `token.image` must be either a `File` or a `Blob` instance, which will be\n     * stored and the corresponding content address URL will be saved in the\n     * metadata JSON file under `image` field.\n     *\n     * If `token.properties` contains properties with `File` or `Blob` values,\n     * those also get stored and their URLs will be saved in the metadata JSON\n     * file in their place.\n     *\n     * Note: URLs for `File` objects will retain file names e.g. in case of\n     * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n     * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n     * objects, the URL will not have a file name name or mime type, instead it\n     * will be transformed into a URL that looks like\n     * `ipfs://bafy...hash/image/blob`.\n     *\n     * @example\n     * ```js\n     * const metadata = await client.store({\n     *   name: 'nft.storage store test',\n     *   description: 'Test ERC-1155 compatible metadata.',\n     *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n     *   properties: {\n     *     custom: 'Custom data can appear here, files are auto uploaded.',\n     *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n     *   }\n     * })\n     *\n     * console.log('IPFS URL for the metadata:', metadata.url)\n     * console.log('metadata.json contents:\\n', metadata.data)\n     * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n     * ```\n     *\n     * @template {import('./lib/interface.js').TokenInput} T\n     * @param {T} token\n     * @param {RequestOptions} [options]\n     */\n  }, {\n    key: \"store\",\n    value: function store(token, options) {\n      return NFTStorage.store(this, token, options);\n    }\n  }], [{\n    key: \"auth\",\n    value: function auth(_ref4) {\n      var token = _ref4.token,\n        did = _ref4.did;\n      if (!token) throw new Error('missing token');\n      return _objectSpread({\n        Authorization: \"Bearer \".concat(token),\n        'X-Client': 'nft.storage/js'\n      }, did ? {\n        'x-agent-did': did\n      } : {});\n    }\n\n    /**\n     * Stores a single file and returns its CID.\n     *\n     * @param {Service} service\n     * @param {Blob} blob\n     * @param {RequestOptions} [options]\n     * @returns {Promise<CIDString>}\n     */\n  }, {\n    key: \"storeBlob\",\n    value: function () {\n      var _storeBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(service, blob, options) {\n        var blockstore, cidString, _yield$NFTStorage$enc, cid, car;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                blockstore = new Blockstore();\n                _context.prev = 1;\n                _context.next = 4;\n                return NFTStorage.encodeBlob(blob, {\n                  blockstore: blockstore\n                });\n              case 4:\n                _yield$NFTStorage$enc = _context.sent;\n                cid = _yield$NFTStorage$enc.cid;\n                car = _yield$NFTStorage$enc.car;\n                _context.next = 9;\n                return NFTStorage.storeCar(service, car, options);\n              case 9:\n                cidString = cid.toString();\n              case 10:\n                _context.prev = 10;\n                _context.next = 13;\n                return blockstore.close();\n              case 13:\n                return _context.finish(10);\n              case 14:\n                return _context.abrupt(\"return\", cidString);\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1,, 10, 14]]);\n      }));\n      function storeBlob(_x2, _x3, _x4) {\n        return _storeBlob.apply(this, arguments);\n      }\n      return storeBlob;\n    }()\n    /**\n     * Stores a CAR file and returns its root CID.\n     *\n     * @param {Service} service\n     * @param {Blob|CarReader} car\n     * @param {import('./lib/interface.js').CarStorerOptions} [options]\n     * @returns {Promise<CIDString>}\n     */\n  }, {\n    key: \"storeCar\",\n    value: function () {\n      var _storeCar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref5, car) {\n        var endpoint,\n          _ref5$rateLimiter,\n          rateLimiter,\n          token,\n          _ref6,\n          onStoredChunk,\n          maxRetries,\n          decoders,\n          signal,\n          url,\n          headers,\n          targetSize,\n          splitter,\n          upload,\n          root,\n          _iteratorAbruptCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          cid,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                endpoint = _ref5.endpoint, _ref5$rateLimiter = _ref5.rateLimiter, rateLimiter = _ref5$rateLimiter === void 0 ? globalRateLimiter : _ref5$rateLimiter, token = _objectWithoutProperties(_ref5, _excluded);\n                _ref6 = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {}, onStoredChunk = _ref6.onStoredChunk, maxRetries = _ref6.maxRetries, decoders = _ref6.decoders, signal = _ref6.signal;\n                url = new URL('upload/', endpoint);\n                headers = NFTStorage.auth(token);\n                targetSize = MAX_CHUNK_SIZE;\n                if (!(car instanceof Blob)) {\n                  _context4.next = 11;\n                  break;\n                }\n                _context4.next = 8;\n                return TreewalkCarSplitter.fromBlob(car, targetSize, {\n                  decoders: decoders\n                });\n              case 8:\n                _context4.t0 = _context4.sent;\n                _context4.next = 12;\n                break;\n              case 11:\n                _context4.t0 = new TreewalkCarSplitter(car, targetSize, {\n                  decoders: decoders\n                });\n              case 12:\n                splitter = _context4.t0;\n                upload = transform(MAX_CONCURRENT_UPLOADS, /*#__PURE__*/function () {\n                  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3( /** @type {AsyncIterable<Uint8Array>} */car) {\n                    var carParts, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, part, carFile, cid;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            carParts = [];\n                            _iteratorAbruptCompletion2 = false;\n                            _didIteratorError2 = false;\n                            _context3.prev = 3;\n                            _iterator2 = _asyncIterator(car);\n                          case 5:\n                            _context3.next = 7;\n                            return _iterator2.next();\n                          case 7:\n                            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                              _context3.next = 13;\n                              break;\n                            }\n                            part = _step2.value;\n                            carParts.push(part);\n                          case 10:\n                            _iteratorAbruptCompletion2 = false;\n                            _context3.next = 5;\n                            break;\n                          case 13:\n                            _context3.next = 19;\n                            break;\n                          case 15:\n                            _context3.prev = 15;\n                            _context3.t0 = _context3[\"catch\"](3);\n                            _didIteratorError2 = true;\n                            _iteratorError2 = _context3.t0;\n                          case 19:\n                            _context3.prev = 19;\n                            _context3.prev = 20;\n                            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                              _context3.next = 24;\n                              break;\n                            }\n                            _context3.next = 24;\n                            return _iterator2.return();\n                          case 24:\n                            _context3.prev = 24;\n                            if (!_didIteratorError2) {\n                              _context3.next = 27;\n                              break;\n                            }\n                            throw _iteratorError2;\n                          case 27:\n                            return _context3.finish(24);\n                          case 28:\n                            return _context3.finish(19);\n                          case 29:\n                            carFile = new Blob(carParts, {\n                              type: 'application/car'\n                            });\n                            _context3.next = 32;\n                            return pRetry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                              var response, result;\n                              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                                while (1) {\n                                  switch (_context2.prev = _context2.next) {\n                                    case 0:\n                                      _context2.next = 2;\n                                      return rateLimiter();\n                                    case 2:\n                                      _context2.prev = 2;\n                                      _context2.next = 5;\n                                      return fetch(url.toString(), {\n                                        method: 'POST',\n                                        headers: headers,\n                                        body: carFile,\n                                        signal: signal\n                                      });\n                                    case 5:\n                                      response = _context2.sent;\n                                      _context2.next = 11;\n                                      break;\n                                    case 8:\n                                      _context2.prev = 8;\n                                      _context2.t0 = _context2[\"catch\"](2);\n                                      throw signal && signal.aborted ? new AbortError(_context2.t0) : _context2.t0;\n                                    case 11:\n                                      if (!(response.status === 429)) {\n                                        _context2.next = 13;\n                                        break;\n                                      }\n                                      throw new Error('rate limited');\n                                    case 13:\n                                      _context2.next = 15;\n                                      return response.json();\n                                    case 15:\n                                      result = _context2.sent;\n                                      if (result.ok) {\n                                        _context2.next = 20;\n                                        break;\n                                      }\n                                      if (!(response.status === 401)) {\n                                        _context2.next = 19;\n                                        break;\n                                      }\n                                      throw new AbortError(result.error.message);\n                                    case 19:\n                                      throw new Error(result.error.message);\n                                    case 20:\n                                      return _context2.abrupt(\"return\", result.value.cid);\n                                    case 21:\n                                    case \"end\":\n                                      return _context2.stop();\n                                  }\n                                }\n                              }, _callee2, null, [[2, 8]]);\n                            })), {\n                              retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries\n                            });\n                          case 32:\n                            cid = _context3.sent;\n                            onStoredChunk && onStoredChunk(carFile.size);\n                            return _context3.abrupt(\"return\", cid);\n                          case 35:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, null, [[3, 15, 19, 29], [20,, 24, 28]]);\n                  }));\n                  return function (_x7) {\n                    return _ref7.apply(this, arguments);\n                  };\n                }());\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context4.prev = 16;\n                _iterator = _asyncIterator(upload(splitter.cars()));\n              case 18:\n                _context4.next = 20;\n                return _iterator.next();\n              case 20:\n                if (!(_iteratorAbruptCompletion = !(_step = _context4.sent).done)) {\n                  _context4.next = 26;\n                  break;\n                }\n                cid = _step.value;\n                root = cid;\n              case 23:\n                _iteratorAbruptCompletion = false;\n                _context4.next = 18;\n                break;\n              case 26:\n                _context4.next = 32;\n                break;\n              case 28:\n                _context4.prev = 28;\n                _context4.t1 = _context4[\"catch\"](16);\n                _didIteratorError = true;\n                _iteratorError = _context4.t1;\n              case 32:\n                _context4.prev = 32;\n                _context4.prev = 33;\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context4.next = 37;\n                  break;\n                }\n                _context4.next = 37;\n                return _iterator.return();\n              case 37:\n                _context4.prev = 37;\n                if (!_didIteratorError) {\n                  _context4.next = 40;\n                  break;\n                }\n                throw _iteratorError;\n              case 40:\n                return _context4.finish(37);\n              case 41:\n                return _context4.finish(32);\n              case 42:\n                return _context4.abrupt(\"return\", /** @type {CIDString} */root);\n              case 43:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[16, 28, 32, 42], [33,, 37, 41]]);\n      }));\n      function storeCar(_x5, _x6) {\n        return _storeCar.apply(this, arguments);\n      }\n      return storeCar;\n    }()\n    /**\n     * Stores a directory of files and returns a CID. Provided files **MUST**\n     * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n     * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n     *\n     * @param {Service} service\n     * @param {FilesSource} filesSource\n     * @param {RequestOptions} [options]\n     * @returns {Promise<CIDString>}\n     */\n  }, {\n    key: \"storeDirectory\",\n    value: function () {\n      var _storeDirectory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(service, filesSource, options) {\n        var blockstore, cidString, _yield$NFTStorage$enc2, cid, car;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                blockstore = new Blockstore();\n                _context5.prev = 1;\n                _context5.next = 4;\n                return NFTStorage.encodeDirectory(filesSource, {\n                  blockstore: blockstore\n                });\n              case 4:\n                _yield$NFTStorage$enc2 = _context5.sent;\n                cid = _yield$NFTStorage$enc2.cid;\n                car = _yield$NFTStorage$enc2.car;\n                _context5.next = 9;\n                return NFTStorage.storeCar(service, car, options);\n              case 9:\n                cidString = cid.toString();\n              case 10:\n                _context5.prev = 10;\n                _context5.next = 13;\n                return blockstore.close();\n              case 13:\n                return _context5.finish(10);\n              case 14:\n                return _context5.abrupt(\"return\", cidString);\n              case 15:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[1,, 10, 14]]);\n      }));\n      function storeDirectory(_x8, _x9, _x10) {\n        return _storeDirectory.apply(this, arguments);\n      }\n      return storeDirectory;\n    }()\n    /**\n     * Stores the given token and all resources it references (in the form of a\n     * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n     * `token.image` must be either a `File` or a `Blob` instance, which will be\n     * stored and the corresponding content address URL will be saved in the\n     * metadata JSON file under `image` field.\n     *\n     * If `token.properties` contains properties with `File` or `Blob` values,\n     * those also get stored and their URLs will be saved in the metadata JSON\n     * file in their place.\n     *\n     * Note: URLs for `File` objects will retain file names e.g. in case of\n     * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n     * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n     * objects, the URL will not have a file name name or mime type, instead it\n     * will be transformed into a URL that looks like\n     * `ipfs://bafy...hash/image/blob`.\n     *\n     * @template {import('./lib/interface.js').TokenInput} T\n     * @param {Service} service\n     * @param {T} metadata\n     * @param {RequestOptions} [options]\n     * @returns {Promise<TokenType<T>>}\n     */\n  }, {\n    key: \"store\",\n    value: function () {\n      var _store = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(service, metadata, options) {\n        var _yield$NFTStorage$enc3, token, car;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return NFTStorage.encodeNFT(metadata);\n              case 2:\n                _yield$NFTStorage$enc3 = _context6.sent;\n                token = _yield$NFTStorage$enc3.token;\n                car = _yield$NFTStorage$enc3.car;\n                _context6.next = 7;\n                return NFTStorage.storeCar(service, car, options);\n              case 7:\n                return _context6.abrupt(\"return\", token);\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n      function store(_x11, _x12, _x13) {\n        return _store.apply(this, arguments);\n      }\n      return store;\n    }()\n    /**\n     * Returns current status of the stored NFT by its CID. Note the NFT must\n     * have previously been stored by this account.\n     *\n     * @param {Service} service\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     * @returns {Promise<import('./lib/interface.js').StatusResult>}\n     */\n  }, {\n    key: \"status\",\n    value: function () {\n      var _status = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref9, cid, options) {\n        var endpoint, _ref9$rateLimiter, rateLimiter, token, url, response, result;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                endpoint = _ref9.endpoint, _ref9$rateLimiter = _ref9.rateLimiter, rateLimiter = _ref9$rateLimiter === void 0 ? globalRateLimiter : _ref9$rateLimiter, token = _objectWithoutProperties(_ref9, _excluded2);\n                url = new URL(\"\".concat(cid, \"/\"), endpoint);\n                _context7.next = 4;\n                return rateLimiter();\n              case 4:\n                _context7.next = 6;\n                return fetch(url.toString(), {\n                  method: 'GET',\n                  headers: NFTStorage.auth(token),\n                  signal: options && options.signal\n                });\n              case 6:\n                response = _context7.sent;\n                if (!(response.status === 429)) {\n                  _context7.next = 9;\n                  break;\n                }\n                throw new Error('rate limited');\n              case 9:\n                _context7.next = 11;\n                return response.json();\n              case 11:\n                result = _context7.sent;\n                if (!result.ok) {\n                  _context7.next = 16;\n                  break;\n                }\n                return _context7.abrupt(\"return\", {\n                  cid: result.value.cid,\n                  deals: decodeDeals(result.value.deals),\n                  size: result.value.size,\n                  pin: decodePin(result.value.pin),\n                  created: new Date(result.value.created)\n                });\n              case 16:\n                throw new Error(result.error.message);\n              case 17:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n      function status(_x14, _x15, _x16) {\n        return _status.apply(this, arguments);\n      }\n      return status;\n    }()\n    /**\n     * Check if a CID of an NFT is being stored by NFT.Storage.\n     *\n     * @param {import('./lib/interface.js').PublicService} service\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     * @returns {Promise<import('./lib/interface.js').CheckResult>}\n     */\n  }, {\n    key: \"check\",\n    value: function () {\n      var _check = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref10, cid, options) {\n        var endpoint, _ref10$rateLimiter, rateLimiter, url, response, result;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                endpoint = _ref10.endpoint, _ref10$rateLimiter = _ref10.rateLimiter, rateLimiter = _ref10$rateLimiter === void 0 ? globalRateLimiter : _ref10$rateLimiter;\n                url = new URL(\"check/\".concat(cid, \"/\"), endpoint);\n                _context8.next = 4;\n                return rateLimiter();\n              case 4:\n                _context8.next = 6;\n                return fetch(url.toString(), {\n                  signal: options && options.signal\n                });\n              case 6:\n                response = _context8.sent;\n                if (!(response.status === 429)) {\n                  _context8.next = 9;\n                  break;\n                }\n                throw new Error('rate limited');\n              case 9:\n                _context8.next = 11;\n                return response.json();\n              case 11:\n                result = _context8.sent;\n                if (!result.ok) {\n                  _context8.next = 16;\n                  break;\n                }\n                return _context8.abrupt(\"return\", {\n                  cid: result.value.cid,\n                  deals: decodeDeals(result.value.deals),\n                  pin: result.value.pin\n                });\n              case 16:\n                throw new Error(result.error.message);\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n      function check(_x17, _x18, _x19) {\n        return _check.apply(this, arguments);\n      }\n      return check;\n    }()\n    /**\n     * Removes stored content by its CID from this account. Please note that\n     * even if content is removed from the service other nodes that have\n     * replicated it might still continue providing it.\n     *\n     * @param {Service} service\n     * @param {string} cid\n     * @param {RequestOptions} [options]\n     * @returns {Promise<void>}\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref11, cid, options) {\n        var endpoint, _ref11$rateLimiter, rateLimiter, token, url, response, result;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                endpoint = _ref11.endpoint, _ref11$rateLimiter = _ref11.rateLimiter, rateLimiter = _ref11$rateLimiter === void 0 ? globalRateLimiter : _ref11$rateLimiter, token = _objectWithoutProperties(_ref11, _excluded3);\n                url = new URL(\"\".concat(cid, \"/\"), endpoint);\n                _context9.next = 4;\n                return rateLimiter();\n              case 4:\n                _context9.next = 6;\n                return fetch(url.toString(), {\n                  method: 'DELETE',\n                  headers: NFTStorage.auth(token),\n                  signal: options && options.signal\n                });\n              case 6:\n                response = _context9.sent;\n                if (!(response.status === 429)) {\n                  _context9.next = 9;\n                  break;\n                }\n                throw new Error('rate limited');\n              case 9:\n                _context9.next = 11;\n                return response.json();\n              case 11:\n                result = _context9.sent;\n                if (result.ok) {\n                  _context9.next = 14;\n                  break;\n                }\n                throw new Error(result.error.message);\n              case 14:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n      function _delete(_x20, _x21, _x22) {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n    /**\n     * Encodes the given token and all resources it references (in the form of a\n     * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n     * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n     * which will be stored and the corresponding content address URL will be\n     * saved in the metadata JSON file under `image` field.\n     *\n     * If `token.properties` contains properties with `File` or `Blob` values,\n     * those also get stored and their URLs will be saved in the metadata JSON\n     * file in their place.\n     *\n     * Note: URLs for `File` objects will retain file names e.g. in case of\n     * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n     * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n     * objects, the URL will not have a file name name or mime type, instead it\n     * will be transformed into a URL that looks like\n     * `ipfs://bafy...hash/image/blob`.\n     *\n     * @example\n     * ```js\n     * const { token, car } = await NFTStorage.encodeNFT({\n     *   name: 'nft.storage store test',\n     *   description: 'Test ERC-1155 compatible metadata.',\n     *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n     *   properties: {\n     *     custom: 'Custom data can appear here, files are auto uploaded.',\n     *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n     *   }\n     * })\n     *\n     * console.log('IPFS URL for the metadata:', token.url)\n     * console.log('metadata.json contents:\\n', token.data)\n     * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n     *\n     * // Now store the CAR file on NFT.Storage\n     * await client.storeCar(car)\n     * ```\n     *\n     * @template {import('./lib/interface.js').TokenInput} T\n     * @param {T} input\n     * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n     */\n  }, {\n    key: \"encodeNFT\",\n    value: function () {\n      var _encodeNFT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(input) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                validateERC1155(input);\n                return _context10.abrupt(\"return\", Token.Token.encode(input));\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n      function encodeNFT(_x23) {\n        return _encodeNFT.apply(this, arguments);\n      }\n      return encodeNFT;\n    }()\n    /**\n     * Encodes a single file to a CAR file and also returns its root CID.\n     *\n     * @example\n     * ```js\n     * const content = new Blob(['hello world'])\n     * const { cid, car } = await NFTStorage.encodeBlob(content)\n     *\n     * // Root CID of the file\n     * console.log(cid.toString())\n     *\n     * // Now store the CAR file on NFT.Storage\n     * await client.storeCar(car)\n     * ```\n     *\n     * @param {Blob} blob\n     * @param {object} [options]\n     * @param {BlockstoreI} [options.blockstore]\n     * @returns {Promise<{ cid: CID, car: CarReader }>}\n     */\n  }, {\n    key: \"encodeBlob\",\n    value: function () {\n      var _encodeBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(blob) {\n        var _ref12,\n          blockstore,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _ref12 = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {}, blockstore = _ref12.blockstore;\n                if (!(blob.size === 0)) {\n                  _context11.next = 3;\n                  break;\n                }\n                throw new Error('Content size is 0, make sure to provide some content');\n              case 3:\n                return _context11.abrupt(\"return\", packCar([toImportCandidate('blob', blob)], {\n                  blockstore: blockstore,\n                  wrapWithDirectory: false\n                }));\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n      function encodeBlob(_x24) {\n        return _encodeBlob.apply(this, arguments);\n      }\n      return encodeBlob;\n    }()\n    /**\n     * Encodes a directory of files to a CAR file and also returns the root CID.\n     * Provided files **MUST** be within the same directory, otherwise error is\n     * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n     * `bla/baz.json` is not.\n     *\n     * @example\n     * ```js\n     * const { cid, car } = await NFTStorage.encodeDirectory([\n     *   new File(['hello world'], 'hello.txt'),\n     *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n     * ])\n     *\n     * // Root CID of the directory\n     * console.log(cid.toString())\n     *\n     * // Now store the CAR file on NFT.Storage\n     * await client.storeCar(car)\n     * ```\n     *\n     * @param {FilesSource} files\n     * @param {object} [options]\n     * @param {BlockstoreI} [options.blockstore]\n     * @returns {Promise<{ cid: CID, car: CarReader }>}\n     */\n  }, {\n    key: \"encodeDirectory\",\n    value: function () {\n      var _encodeDirectory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(files) {\n        var _ref13,\n          blockstore,\n          size,\n          input,\n          packed,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _ref13 = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {}, blockstore = _ref13.blockstore;\n                size = 0;\n                input = pipe(files, /*#__PURE__*/function () {\n                  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(files) {\n                    var _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, file;\n                    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n                      while (1) {\n                        switch (_context12.prev = _context12.next) {\n                          case 0:\n                            _iteratorAbruptCompletion3 = false;\n                            _didIteratorError3 = false;\n                            _context12.prev = 2;\n                            _iterator3 = _asyncIterator(files);\n                          case 4:\n                            _context12.next = 6;\n                            return _awaitAsyncGenerator(_iterator3.next());\n                          case 6:\n                            if (!(_iteratorAbruptCompletion3 = !(_step3 = _context12.sent).done)) {\n                              _context12.next = 14;\n                              break;\n                            }\n                            file = _step3.value;\n                            _context12.next = 10;\n                            return toImportCandidate(file.name, file);\n                          case 10:\n                            size += file.size;\n                          case 11:\n                            _iteratorAbruptCompletion3 = false;\n                            _context12.next = 4;\n                            break;\n                          case 14:\n                            _context12.next = 20;\n                            break;\n                          case 16:\n                            _context12.prev = 16;\n                            _context12.t0 = _context12[\"catch\"](2);\n                            _didIteratorError3 = true;\n                            _iteratorError3 = _context12.t0;\n                          case 20:\n                            _context12.prev = 20;\n                            _context12.prev = 21;\n                            if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {\n                              _context12.next = 25;\n                              break;\n                            }\n                            _context12.next = 25;\n                            return _awaitAsyncGenerator(_iterator3.return());\n                          case 25:\n                            _context12.prev = 25;\n                            if (!_didIteratorError3) {\n                              _context12.next = 28;\n                              break;\n                            }\n                            throw _iteratorError3;\n                          case 28:\n                            return _context12.finish(25);\n                          case 29:\n                            return _context12.finish(20);\n                          case 30:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }\n                    }, _callee12, null, [[2, 16, 20, 30], [21,, 25, 29]]);\n                  }));\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n                _context13.next = 5;\n                return packCar(input, {\n                  blockstore: blockstore,\n                  wrapWithDirectory: true\n                });\n              case 5:\n                packed = _context13.sent;\n                if (!(size === 0)) {\n                  _context13.next = 8;\n                  break;\n                }\n                throw new Error('Total size of files should exceed 0, make sure to provide some content');\n              case 8:\n                return _context13.abrupt(\"return\", packed);\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n      function encodeDirectory(_x25) {\n        return _encodeDirectory.apply(this, arguments);\n      }\n      return encodeDirectory;\n    }()\n  }]);\n  return NFTStorage;\n}();\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n    var _iterator4, _step4, item;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _iterator4 = _createForOfIteratorHelper(iterable);\n            _context14.prev = 1;\n            _iterator4.s();\n          case 3:\n            if ((_step4 = _iterator4.n()).done) {\n              _context14.next = 9;\n              break;\n            }\n            item = _step4.value;\n            _context14.next = 7;\n            return item;\n          case 7:\n            _context14.next = 3;\n            break;\n          case 9:\n            _context14.next = 14;\n            break;\n          case 11:\n            _context14.prev = 11;\n            _context14.t0 = _context14[\"catch\"](1);\n            _iterator4.e(_context14.t0);\n          case 14:\n            _context14.prev = 14;\n            _iterator4.f();\n            return _context14.finish(14);\n          case 17:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14, null, [[1, 11, 14, 17]]);\n  }))();\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nvar validateERC1155 = function validateERC1155(_ref14) {\n  var name = _ref14.name,\n    description = _ref14.description,\n    image = _ref14.image,\n    decimals = _ref14.decimals;\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError('string property `name` identifying the asset is required');\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError('string property `description` describing asset is required');\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object');\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(\"According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\\n\\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. `properties: { video: file }` and using 'image' field for storing a preview image for it instead.\\n\\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721\");\n  }\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value');\n  }\n};\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nvar packCar = /*#__PURE__*/function () {\n  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(input) {\n    var _ref16,\n      blockstore,\n      wrapWithDirectory,\n      _yield$pack,\n      cid,\n      car,\n      _args15 = arguments;\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _ref16 = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {}, blockstore = _ref16.blockstore, wrapWithDirectory = _ref16.wrapWithDirectory;\n            /* c8 ignore next 1 */\n            blockstore = blockstore || new Blockstore();\n            _context15.next = 4;\n            return pack({\n              input: input,\n              blockstore: blockstore,\n              wrapWithDirectory: wrapWithDirectory\n            });\n          case 4:\n            _yield$pack = _context15.sent;\n            cid = _yield$pack.root;\n            car = new BlockstoreCarReader(1, [cid], blockstore);\n            return _context15.abrupt(\"return\", {\n              cid: cid,\n              car: car\n            });\n          case 8:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return function packCar(_x26) {\n    return _ref15.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nvar decodeDeals = function decodeDeals(deals) {\n  return deals.map(function (deal) {\n    var _dealExpiration$dealA = _objectSpread({\n        dealExpiration: null,\n        dealActivation: null\n      }, deal),\n      dealActivation = _dealExpiration$dealA.dealActivation,\n      dealExpiration = _dealExpiration$dealA.dealExpiration,\n      lastChanged = _dealExpiration$dealA.lastChanged;\n    return _objectSpread(_objectSpread(_objectSpread({}, deal), {}, {\n      lastChanged: new Date(lastChanged)\n    }, dealActivation && {\n      dealActivation: new Date(dealActivation)\n    }), dealExpiration && {\n      dealExpiration: new Date(dealExpiration)\n    });\n  });\n};\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nvar decodePin = function decodePin(pin) {\n  return _objectSpread(_objectSpread({}, pin), {}, {\n    created: new Date(pin.created)\n  });\n};\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  var stream;\n  return {\n    path: path,\n    get content() {\n      stream = stream || blob.stream();\n      return stream;\n    }\n  };\n}\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token };","map":{"version":3,"names":["transform","pRetry","AbortError","TreewalkCarSplitter","pack","CID","throttledQueue","Token","fetch","File","Blob","FormData","Blockstore","toGatewayURL","BlockstoreCarReader","pipe","MAX_STORE_RETRIES","MAX_CONCURRENT_UPLOADS","MAX_CHUNK_SIZE","RATE_LIMIT_REQUESTS","RATE_LIMIT_PERIOD","createRateLimiter","throttle","globalRateLimiter","NFTStorage","token","did","endpoint","URL","rateLimiter","blob","options","storeBlob","car","storeCar","files","storeDirectory","cid","status","delete","check","store","Error","Authorization","service","blockstore","encodeBlob","cidString","toString","close","onStoredChunk","maxRetries","decoders","signal","url","headers","auth","targetSize","fromBlob","splitter","upload","carParts","part","push","carFile","type","method","body","response","aborted","json","result","ok","error","message","value","retries","size","cars","root","filesSource","encodeDirectory","metadata","encodeNFT","deals","decodeDeals","pin","decodePin","created","Date","input","validateERC1155","encode","packCar","toImportCandidate","wrapWithDirectory","file","name","packed","toAsyncIterable","iterable","item","description","image","decimals","TypeError","startsWith","console","warn","map","deal","dealExpiration","dealActivation","lastChanged","path","stream","content"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/nft.storage/src/lib.js"],"sourcesContent":["/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport throttledQueue from 'throttled-queue'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\nimport pipe from 'it-pipe'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = NFTStorage.auth(token)\n    const targetSize = MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, { type: 'application/car' })\n        const cid = await pRetry(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await fetch(url.toString(), {\n                method: 'POST',\n                headers,\n                body: carFile,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return Token.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = pipe(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore()\n  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory })\n  const car = new BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token }\n"],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,SAAS,QAAQ,qBAAqB;AAC/C,OAAOC,MAAM,IAAIC,UAAU,QAAQ,SAAS;AAC5C,SAASC,mBAAmB,QAAQ,mBAAmB;AACvD,SAASC,IAAI,QAAQ,eAAe;AACpC,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAOC,cAAc,MAAM,iBAAiB;AAC5C,OAAO,KAAKC,KAAK,MAAM,YAAY;AACnC,SAASC,KAAK,EAAEC,IAAI,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,QAAQ,eAAe;AACvE,SAASC,YAAY,QAAQ,cAAc;AAC3C,SAASC,mBAAmB,QAAQ,oBAAoB;AACxD,OAAOC,IAAI,MAAM,SAAS;AAE1B,IAAMC,iBAAiB,GAAG,CAAC;AAC3B,IAAMC,sBAAsB,GAAG,CAAC;AAChC,IAAMC,cAAc,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,EAAC;AACxC,IAAMC,mBAAmB,GAAG,EAAE;AAC9B,IAAMC,iBAAiB,GAAG,EAAE,GAAG,IAAI;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAASC,iBAAiB,GAAG;EAClC,IAAMC,QAAQ,GAAGhB,cAAc,CAACa,mBAAmB,EAAEC,iBAAiB,CAAC;EACvE,OAAO;IAAA,OAAME,QAAQ,CAAC,YAAM,CAAC,CAAC,CAAC;EAAA;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAMC,iBAAiB,GAAGF,iBAAiB,EAAE;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA,IAGMG,UAAU;EACd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,2BAKG;IAAA,IAJDC,KAAK,SAALA,KAAK;MACLC,GAAG,SAAHA,GAAG;MAAA,uBACHC,QAAQ;MAARA,QAAQ,+BAAG,IAAIC,GAAG,CAAC,yBAAyB,CAAC;MAC7CC,WAAW,SAAXA,WAAW;IAAA;IAEX;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACJ,KAAK,GAAGA,KAAK;IAClB;AACJ;AACA;AACA;IACI,IAAI,CAACE,QAAQ,GAAGA,QAAQ;IACxB;AACJ;AACA;IACI,IAAI,CAACE,WAAW,GAAGA,WAAW,IAAIR,iBAAiB,EAAE;;IAErD;AACJ;AACA;IACI,IAAI,CAACK,GAAG,GAAGA,GAAG;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAA;IAAA;IAgZA;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,mBAAUI,IAAI,EAAEC,OAAO,EAAE;MACvB,OAAOP,UAAU,CAACQ,SAAS,CAAC,IAAI,EAAEF,IAAI,EAAEC,OAAO,CAAC;IAClD;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EApCE;IAAA;IAAA,OAqCA,kBAASE,GAAG,EAAEF,OAAO,EAAE;MACrB,OAAOP,UAAU,CAACU,QAAQ,CAAC,IAAI,EAAED,GAAG,EAAEF,OAAO,CAAC;IAChD;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAjBE;IAAA;IAAA,OAkBA,wBAAeI,KAAK,EAAEJ,OAAO,EAAE;MAC7B,OAAOP,UAAU,CAACY,cAAc,CAAC,IAAI,EAAED,KAAK,EAAEJ,OAAO,CAAC;IACxD;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAXE;IAAA;IAAA,OAYA,gBAAOM,GAAG,EAAEN,OAAO,EAAE;MACnB,OAAOP,UAAU,CAACc,MAAM,CAAC,IAAI,EAAED,GAAG,EAAEN,OAAO,CAAC;IAC9C;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAbE;IAAA;IAAA,OAcA,iBAAOM,GAAG,EAAEN,OAAO,EAAE;MACnB,OAAOP,UAAU,CAACe,MAAM,CAAC,IAAI,EAAEF,GAAG,EAAEN,OAAO,CAAC;IAC9C;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAXE;IAAA;IAAA,OAYA,eAAMM,GAAG,EAAEN,OAAO,EAAE;MAClB,OAAOP,UAAU,CAACgB,KAAK,CAAC,IAAI,EAAEH,GAAG,EAAEN,OAAO,CAAC;IAC7C;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAvCE;IAAA;IAAA,OAwCA,eAAMN,KAAK,EAAEM,OAAO,EAAE;MACpB,OAAOP,UAAU,CAACiB,KAAK,CAAC,IAAI,EAAEhB,KAAK,EAAEM,OAAO,CAAC;IAC/C;EAAC;IAAA;IAAA,OA3jBD,qBAA4B;MAAA,IAAdN,KAAK,SAALA,KAAK;QAAEC,GAAG,SAAHA,GAAG;MACtB,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIiB,KAAK,CAAC,eAAe,CAAC;MAC5C;QACEC,aAAa,mBAAYlB,KAAK,CAAE;QAChC,UAAU,EAAE;MAAgB,GACxBC,GAAG,GAAG;QAAE,aAAa,EAAEA;MAAI,CAAC,GAAG,CAAC,CAAC;IAEzC;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA;IAAA;MAAA,4EAQA,iBAAuBkB,OAAO,EAAEd,IAAI,EAAEC,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBACrCc,UAAU,GAAG,IAAIjC,UAAU,EAAE;gBAAA;gBAAA;gBAAA,OAINY,UAAU,CAACsB,UAAU,CAAChB,IAAI,EAAE;kBAAEe,UAAU,EAAVA;gBAAW,CAAC,CAAC;cAAA;gBAAA;gBAA9DR,GAAG,yBAAHA,GAAG;gBAAEJ,GAAG,yBAAHA,GAAG;gBAAA;gBAAA,OACVT,UAAU,CAACU,QAAQ,CAACU,OAAO,EAAEX,GAAG,EAAEF,OAAO,CAAC;cAAA;gBAChDgB,SAAS,GAAGV,GAAG,CAACW,QAAQ,EAAE;cAAA;gBAAA;gBAAA;gBAAA,OAEpBH,UAAU,CAACI,KAAK,EAAE;cAAA;gBAAA;cAAA;gBAAA,iCAGnBF,SAAS;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA;IAAA;MAAA,2EAQA,yBAEEd,GAAG;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBADDN,QAAQ,SAARA,QAAQ,4BAAEE,WAAW,EAAXA,WAAW,kCAAGN,iBAAiB,sBAAKE,KAAK;gBAAA,mEAEH,CAAC,CAAC,EAAlDyB,aAAa,SAAbA,aAAa,EAAEC,UAAU,SAAVA,UAAU,EAAEC,QAAQ,SAARA,QAAQ,EAAEC,MAAM,SAANA,MAAM;gBAEvCC,GAAG,GAAG,IAAI1B,GAAG,CAAC,SAAS,EAAED,QAAQ,CAAC;gBAClC4B,OAAO,GAAG/B,UAAU,CAACgC,IAAI,CAAC/B,KAAK,CAAC;gBAChCgC,UAAU,GAAGvC,cAAc;gBAAA,MAE/Be,GAAG,YAAYvB,IAAI;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACTP,mBAAmB,CAACuD,QAAQ,CAACzB,GAAG,EAAEwB,UAAU,EAAE;kBAAEL,QAAQ,EAARA;gBAAS,CAAC,CAAC;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA,eACjE,IAAIjD,mBAAmB,CAAC8B,GAAG,EAAEwB,UAAU,EAAE;kBAAEL,QAAQ,EAARA;gBAAS,CAAC,CAAC;cAAA;gBAHtDO,QAAQ;gBAKRC,MAAM,GAAG5D,SAAS,CACtBiB,sBAAsB;kBAAA,uEACtB,mBAAgB,wCAAyCgB,GAAG;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BACpD4B,QAAQ,GAAG,EAAE;4BAAA;4BAAA;4BAAA;4BAAA,4BACM5B,GAAG;0BAAA;4BAAA;4BAAA;0BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAX6B,IAAI;4BACnBD,QAAQ,CAACE,IAAI,CAACD,IAAI,CAAC;0BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAA;0BAAA;4BAAA;0BAAA;4BAAA;0BAAA;4BAEfE,OAAO,GAAG,IAAItD,IAAI,CAACmD,QAAQ,EAAE;8BAAEI,IAAI,EAAE;4BAAkB,CAAC,CAAC;4BAAA;4BAAA,OAC7ChE,MAAM,0EACtB;8BAAA;8BAAA;gCAAA;kCAAA;oCAAA;sCAAA;sCAAA,OACQ4B,WAAW,EAAE;oCAAA;sCAAA;sCAAA;sCAAA,OAIArB,KAAK,CAAC8C,GAAG,CAACN,QAAQ,EAAE,EAAE;wCACrCkB,MAAM,EAAE,MAAM;wCACdX,OAAO,EAAPA,OAAO;wCACPY,IAAI,EAAEH,OAAO;wCACbX,MAAM,EAANA;sCACF,CAAC,CAAC;oCAAA;sCALFe,QAAQ;sCAAA;sCAAA;oCAAA;sCAAA;sCAAA;sCAAA,MASFf,MAAM,IAAIA,MAAM,CAACgB,OAAO,GAAG,IAAInE,UAAU,cAAK,eAAM;oCAAA;sCAAA,MAGxDkE,QAAQ,CAAC9B,MAAM,KAAK,GAAG;wCAAA;wCAAA;sCAAA;sCAAA,MACnB,IAAII,KAAK,CAAC,cAAc,CAAC;oCAAA;sCAAA;sCAAA,OAEZ0B,QAAQ,CAACE,IAAI,EAAE;oCAAA;sCAA9BC,MAAM;sCAAA,IACPA,MAAM,CAACC,EAAE;wCAAA;wCAAA;sCAAA;sCAAA,MAERJ,QAAQ,CAAC9B,MAAM,KAAK,GAAG;wCAAA;wCAAA;sCAAA;sCAAA,MACnB,IAAIpC,UAAU,CAACqE,MAAM,CAACE,KAAK,CAACC,OAAO,CAAC;oCAAA;sCAAA,MAEtC,IAAIhC,KAAK,CAAC6B,MAAM,CAACE,KAAK,CAACC,OAAO,CAAC;oCAAA;sCAAA,kCAEhCH,MAAM,CAACI,KAAK,CAACtC,GAAG;oCAAA;oCAAA;sCAAA;kCAAA;gCAAA;8BAAA;4BAAA,CACxB,IACD;8BACEuC,OAAO,EAAEzB,UAAU,IAAI,IAAI,GAAGnC,iBAAiB,GAAGmC;4BACpD,CAAC,CACF;0BAAA;4BAlCKd,GAAG;4BAmCTa,aAAa,IAAIA,aAAa,CAACc,OAAO,CAACa,IAAI,CAAC;4BAAA,kCACrCxC,GAAG;0BAAA;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CACX;kBAAA;oBAAA;kBAAA;gBAAA,IACF;gBAAA;gBAAA;gBAAA;gBAAA,2BAGuBuB,MAAM,CAACD,QAAQ,CAACmB,IAAI,EAAE,CAAC;cAAA;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAA9BzC,GAAG;gBAClB0C,IAAI,GAAG1C,GAAG;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBAAA;cAAA;gBAAA;cAAA;gBAAA,kCAGL,wBAA0B0C,IAAI;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACtC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EATE;IAAA;IAAA;MAAA,iFAUA,kBAA4BnC,OAAO,EAAEoC,WAAW,EAAEjD,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBACjDc,UAAU,GAAG,IAAIjC,UAAU,EAAE;gBAAA;gBAAA;gBAAA,OAGNY,UAAU,CAACyD,eAAe,CAACD,WAAW,EAAE;kBACjEnC,UAAU,EAAVA;gBACF,CAAC,CAAC;cAAA;gBAAA;gBAFMR,GAAG,0BAAHA,GAAG;gBAAEJ,GAAG,0BAAHA,GAAG;gBAAA;gBAAA,OAGVT,UAAU,CAACU,QAAQ,CAACU,OAAO,EAAEX,GAAG,EAAEF,OAAO,CAAC;cAAA;gBAChDgB,SAAS,GAAGV,GAAG,CAACW,QAAQ,EAAE;cAAA;gBAAA;gBAAA;gBAAA,OAEpBH,UAAU,CAACI,KAAK,EAAE;cAAA;gBAAA;cAAA;gBAAA,kCAGnBF,SAAS;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAvBE;IAAA;IAAA;MAAA,wEAwBA,kBAAmBH,OAAO,EAAEsC,QAAQ,EAAEnD,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACdP,UAAU,CAAC2D,SAAS,CAACD,QAAQ,CAAC;cAAA;gBAAA;gBAAnDzD,KAAK,0BAALA,KAAK;gBAAEQ,GAAG,0BAAHA,GAAG;gBAAA;gBAAA,OACZT,UAAU,CAACU,QAAQ,CAACU,OAAO,EAAEX,GAAG,EAAEF,OAAO,CAAC;cAAA;gBAAA,kCACzCN,KAAK;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACb;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARE;IAAA;IAAA;MAAA,yEASA,yBAEEY,GAAG,EACHN,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAFLJ,QAAQ,SAARA,QAAQ,4BAAEE,WAAW,EAAXA,WAAW,kCAAGN,iBAAiB,sBAAKE,KAAK;gBAI/C6B,GAAG,GAAG,IAAI1B,GAAG,WAAIS,GAAG,QAAKV,QAAQ,CAAC;gBAAA;gBAAA,OAClCE,WAAW,EAAE;cAAA;gBAAA;gBAAA,OACIrB,KAAK,CAAC8C,GAAG,CAACN,QAAQ,EAAE,EAAE;kBAC3CkB,MAAM,EAAE,KAAK;kBACbX,OAAO,EAAE/B,UAAU,CAACgC,IAAI,CAAC/B,KAAK,CAAC;kBAC/B4B,MAAM,EAAEtB,OAAO,IAAIA,OAAO,CAACsB;gBAC7B,CAAC,CAAC;cAAA;gBAJIe,QAAQ;gBAAA,MAMVA,QAAQ,CAAC9B,MAAM,KAAK,GAAG;kBAAA;kBAAA;gBAAA;gBAAA,MACnB,IAAII,KAAK,CAAC,cAAc,CAAC;cAAA;gBAAA;gBAAA,OAEZ0B,QAAQ,CAACE,IAAI,EAAE;cAAA;gBAA9BC,MAAM;gBAAA,KAERA,MAAM,CAACC,EAAE;kBAAA;kBAAA;gBAAA;gBAAA,kCACJ;kBACLnC,GAAG,EAAEkC,MAAM,CAACI,KAAK,CAACtC,GAAG;kBACrB+C,KAAK,EAAEC,WAAW,CAACd,MAAM,CAACI,KAAK,CAACS,KAAK,CAAC;kBACtCP,IAAI,EAAEN,MAAM,CAACI,KAAK,CAACE,IAAI;kBACvBS,GAAG,EAAEC,SAAS,CAAChB,MAAM,CAACI,KAAK,CAACW,GAAG,CAAC;kBAChCE,OAAO,EAAE,IAAIC,IAAI,CAAClB,MAAM,CAACI,KAAK,CAACa,OAAO;gBACxC,CAAC;cAAA;gBAAA,MAEK,IAAI9C,KAAK,CAAC6B,MAAM,CAACE,KAAK,CAACC,OAAO,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAExC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA;IAAA;MAAA,wEAQA,0BAEErC,GAAG,EACHN,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAFLJ,QAAQ,UAARA,QAAQ,8BAAEE,WAAW,EAAXA,WAAW,mCAAGN,iBAAiB;gBAIrC+B,GAAG,GAAG,IAAI1B,GAAG,iBAAUS,GAAG,QAAKV,QAAQ,CAAC;gBAAA;gBAAA,OACxCE,WAAW,EAAE;cAAA;gBAAA;gBAAA,OACIrB,KAAK,CAAC8C,GAAG,CAACN,QAAQ,EAAE,EAAE;kBAC3CK,MAAM,EAAEtB,OAAO,IAAIA,OAAO,CAACsB;gBAC7B,CAAC,CAAC;cAAA;gBAFIe,QAAQ;gBAAA,MAIVA,QAAQ,CAAC9B,MAAM,KAAK,GAAG;kBAAA;kBAAA;gBAAA;gBAAA,MACnB,IAAII,KAAK,CAAC,cAAc,CAAC;cAAA;gBAAA;gBAAA,OAEZ0B,QAAQ,CAACE,IAAI,EAAE;cAAA;gBAA9BC,MAAM;gBAAA,KAERA,MAAM,CAACC,EAAE;kBAAA;kBAAA;gBAAA;gBAAA,kCACJ;kBACLnC,GAAG,EAAEkC,MAAM,CAACI,KAAK,CAACtC,GAAG;kBACrB+C,KAAK,EAAEC,WAAW,CAACd,MAAM,CAACI,KAAK,CAACS,KAAK,CAAC;kBACtCE,GAAG,EAAEf,MAAM,CAACI,KAAK,CAACW;gBACpB,CAAC;cAAA;gBAAA,MAEK,IAAI5C,KAAK,CAAC6B,MAAM,CAACE,KAAK,CAACC,OAAO,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAExC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EATE;IAAA;IAAA;MAAA,0EAUA,0BAEErC,GAAG,EACHN,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAFLJ,QAAQ,UAARA,QAAQ,8BAAEE,WAAW,EAAXA,WAAW,mCAAGN,iBAAiB,uBAAKE,KAAK;gBAI/C6B,GAAG,GAAG,IAAI1B,GAAG,WAAIS,GAAG,QAAKV,QAAQ,CAAC;gBAAA;gBAAA,OAClCE,WAAW,EAAE;cAAA;gBAAA;gBAAA,OACIrB,KAAK,CAAC8C,GAAG,CAACN,QAAQ,EAAE,EAAE;kBAC3CkB,MAAM,EAAE,QAAQ;kBAChBX,OAAO,EAAE/B,UAAU,CAACgC,IAAI,CAAC/B,KAAK,CAAC;kBAC/B4B,MAAM,EAAEtB,OAAO,IAAIA,OAAO,CAACsB;gBAC7B,CAAC,CAAC;cAAA;gBAJIe,QAAQ;gBAAA,MAMVA,QAAQ,CAAC9B,MAAM,KAAK,GAAG;kBAAA;kBAAA;gBAAA;gBAAA,MACnB,IAAII,KAAK,CAAC,cAAc,CAAC;cAAA;gBAAA;gBAAA,OAEZ0B,QAAQ,CAACE,IAAI,EAAE;cAAA;gBAA9BC,MAAM;gBAAA,IACPA,MAAM,CAACC,EAAE;kBAAA;kBAAA;gBAAA;gBAAA,MACN,IAAI9B,KAAK,CAAC6B,MAAM,CAACE,KAAK,CAACC,OAAO,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAExC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAzCE;IAAA;IAAA;MAAA,4EA0CA,mBAAuBgB,KAAK;QAAA;UAAA;YAAA;cAAA;gBAC1BC,eAAe,CAACD,KAAK,CAAC;gBAAA,mCACfnF,KAAK,CAACA,KAAK,CAACqF,MAAM,CAACF,KAAK,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAnBE;IAAA;IAAA;MAAA,6EAoBA,mBAAwB5D,IAAI;QAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,uEAAmB,CAAC,CAAC,EAAjBe,UAAU,UAAVA,UAAU;gBAAA,MACpCf,IAAI,CAAC+C,IAAI,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MACX,IAAInC,KAAK,CAAC,sDAAsD,CAAC;cAAA;gBAAA,mCAElEmD,OAAO,CAAC,CAACC,iBAAiB,CAAC,MAAM,EAAEhE,IAAI,CAAC,CAAC,EAAE;kBAChDe,UAAU,EAAVA,UAAU;kBACVkD,iBAAiB,EAAE;gBACrB,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACH;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAxBE;IAAA;IAAA;MAAA,kFAyBA,mBAA6B5D,KAAK;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,uEAAmB,CAAC,CAAC,EAAjBU,UAAU,UAAVA,UAAU;gBAC1CgC,IAAI,GAAG,CAAC;gBACNa,KAAK,GAAG3E,IAAI,CAACoB,KAAK;kBAAA,wEAAE,mBAAiBA,KAAK;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BAAA;4BAAA;4BAAA;4BAAA,4BACrBA,KAAK;0BAAA;4BAAA;4BAAA;0BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAb6D,IAAI;4BAAA;4BACnB,OAAMF,iBAAiB,CAACE,IAAI,CAACC,IAAI,EAAED,IAAI,CAAC;0BAAA;4BACxCnB,IAAI,IAAImB,IAAI,CAACnB,IAAI;0BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAA;4BAAA;0BAAA;4BAAA;4BAAA;8BAAA;8BAAA;4BAAA;4BAAA;0BAAA;4BAAA;0BAAA;4BAAA;0BAAA;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CAEpB;kBAAA;oBAAA;kBAAA;gBAAA,IAAC;gBAAA;gBAAA,OACmBgB,OAAO,CAACH,KAAK,EAAE;kBAClC7C,UAAU,EAAVA,UAAU;kBACVkD,iBAAiB,EAAE;gBACrB,CAAC,CAAC;cAAA;gBAHIG,MAAM;gBAAA,MAIRrB,IAAI,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MACN,IAAInC,KAAK,CACb,wEAAwE,CACzE;cAAA;gBAAA,mCAEIwD,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAsLH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAe,CAACC,QAAQ,EAAE;EACxC,OAAO,6DAAC;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,wCACaA,QAAQ;YAAA;YAAA;UAAA;YAAA;cAAA;cAAA;YAAA;YAAhBC,IAAI;YAAA;YACb,OAAMA,IAAI;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEb,IAAG;AACN;;AAEA;AACA;AACA;AACA;AACA,IAAMV,eAAe,GAAG,SAAlBA,eAAe,SAA+C;EAAA,IAAzCM,IAAI,UAAJA,IAAI;IAAEK,WAAW,UAAXA,WAAW;IAAEC,KAAK,UAALA,KAAK;IAAEC,QAAQ,UAARA,QAAQ;EAC3D;EACA,IAAI,OAAOP,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM,IAAIQ,SAAS,CACjB,0DAA0D,CAC3D;EACH;EACA,IAAI,OAAOH,WAAW,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIG,SAAS,CACjB,4DAA4D,CAC7D;EACH;EACA,IAAI,EAAEF,KAAK,YAAY7F,IAAI,CAAC,EAAE;IAC5B,MAAM,IAAI+F,SAAS,CAAC,gDAAgD,CAAC;EACvE,CAAC,MAAM,IAAI,CAACF,KAAK,CAACtC,IAAI,CAACyC,UAAU,CAAC,QAAQ,CAAC,EAAE;IAC3CC,OAAO,CAACC,IAAI,qZAI0E;EACxF;EAEA,IAAI,OAAOJ,QAAQ,KAAK,WAAW,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IACnE,MAAM,IAAIC,SAAS,CAAC,8CAA8C,CAAC;EACrE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAMZ,OAAO;EAAA,wEAAG,mBAAOH,KAAK;IAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YAAA,uEAAsC,CAAC,CAAC,EAApC7C,UAAU,UAAVA,UAAU,EAAEkD,iBAAiB,UAAjBA,iBAAiB;YAC3D;YACAlD,UAAU,GAAGA,UAAU,IAAI,IAAIjC,UAAU,EAAE;YAAA;YAAA,OACfR,IAAI,CAAC;cAAEsF,KAAK,EAALA,KAAK;cAAE7C,UAAU,EAAVA,UAAU;cAAEkD,iBAAiB,EAAjBA;YAAkB,CAAC,CAAC;UAAA;YAAA;YAA5D1D,GAAG,eAAT0C,IAAI;YACN9C,GAAG,GAAG,IAAInB,mBAAmB,CAAC,CAAC,EAAE,CAACuB,GAAG,CAAC,EAAEQ,UAAU,CAAC;YAAA,mCAClD;cAAER,GAAG,EAAHA,GAAG;cAAEJ,GAAG,EAAHA;YAAI,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACpB;EAAA,gBANK4D,OAAO;IAAA;EAAA;AAAA,GAMZ;;AAED;AACA;AACA;AACA;AACA,IAAMR,WAAW,GAAG,SAAdA,WAAW,CAAID,KAAK;EAAA,OACxBA,KAAK,CAACyB,GAAG,CAAC,UAACC,IAAI,EAAK;IAClB;QACEC,cAAc,EAAE,IAAI;QACpBC,cAAc,EAAE;MAAI,GACjBF,IAAI;MAHDE,cAAc,yBAAdA,cAAc;MAAED,cAAc,yBAAdA,cAAc;MAAEE,WAAW,yBAAXA,WAAW;IAMnD,qDACKH,IAAI;MACPG,WAAW,EAAE,IAAIxB,IAAI,CAACwB,WAAW;IAAC,GAC9BD,cAAc,IAAI;MAAEA,cAAc,EAAE,IAAIvB,IAAI,CAACuB,cAAc;IAAE,CAAC,GAC9DD,cAAc,IAAI;MAAEA,cAAc,EAAE,IAAItB,IAAI,CAACsB,cAAc;IAAE,CAAC;EAEtE,CAAC,CAAC;AAAA;;AAEJ;AACA;AACA;AACA;AACA,IAAMxB,SAAS,GAAG,SAAZA,SAAS,CAAID,GAAG;EAAA,uCAAWA,GAAG;IAAEE,OAAO,EAAE,IAAIC,IAAI,CAACH,GAAG,CAACE,OAAO;EAAC;AAAA,CAAG;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,iBAAiB,CAACoB,IAAI,EAAEpF,IAAI,EAAE;EACrC;EACA,IAAIqF,MAAM;EACV,OAAO;IACLD,IAAI,EAAJA,IAAI;IACJ,IAAIE,OAAO,GAAG;MACZD,MAAM,GAAGA,MAAM,IAAIrF,IAAI,CAACqF,MAAM,EAAE;MAChC,OAAOA,MAAM;IACf;EACF,CAAC;AACH;AAEA,SAAS3F,UAAU,EAAEf,IAAI,EAAEC,IAAI,EAAEC,QAAQ,EAAEE,YAAY,EAAEN,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}