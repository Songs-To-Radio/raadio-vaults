{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CID } from 'multiformats/cid';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport { bytesReader, readHeader } from './decoder.js';\nexport var CarWriter = /*#__PURE__*/function () {\n  function CarWriter(roots, encoder) {\n    _classCallCheck(this, CarWriter);\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  _createClass(CarWriter, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(block) {\n        var _this = this;\n        var cid;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!(block.bytes instanceof Uint8Array) || !block.cid)) {\n                  _context.next = 2;\n                  break;\n                }\n                throw new TypeError('Can only write {cid, bytes} objects');\n              case 2:\n                if (!this._ended) {\n                  _context.next = 4;\n                  break;\n                }\n                throw new Error('Already closed');\n              case 4:\n                cid = CID.asCID(block.cid);\n                if (cid) {\n                  _context.next = 7;\n                  break;\n                }\n                throw new TypeError('Can only write {cid, bytes} objects');\n              case 7:\n                this._mutex = this._mutex.then(function () {\n                  return _this._encoder.writeBlock({\n                    cid: cid,\n                    bytes: block.bytes\n                  });\n                });\n                return _context.abrupt(\"return\", this._mutex);\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function put(_x) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._ended) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new Error('Already closed');\n              case 2:\n                _context2.next = 4;\n                return this._mutex;\n              case 4:\n                this._ended = true;\n                return _context2.abrupt(\"return\", this._encoder.close());\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }], [{\n    key: \"create\",\n    value: function create(roots) {\n      roots = toRoots(roots);\n      var _encodeWriter = encodeWriter(),\n        encoder = _encodeWriter.encoder,\n        iterator = _encodeWriter.iterator;\n      var writer = new CarWriter(roots, encoder);\n      var out = new CarWriterOut(iterator);\n      return {\n        writer: writer,\n        out: out\n      };\n    }\n  }, {\n    key: \"createAppender\",\n    value: function createAppender() {\n      var _encodeWriter2 = encodeWriter(),\n        encoder = _encodeWriter2.encoder,\n        iterator = _encodeWriter2.iterator;\n      encoder.setRoots = function () {\n        return Promise.resolve();\n      };\n      var writer = new CarWriter([], encoder);\n      var out = new CarWriterOut(iterator);\n      return {\n        writer: writer,\n        out: out\n      };\n    }\n  }, {\n    key: \"updateRootsInBytes\",\n    value: function () {\n      var _updateRootsInBytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(bytes, roots) {\n        var reader, newHeader;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                reader = bytesReader(bytes);\n                _context3.next = 3;\n                return readHeader(reader);\n              case 3:\n                newHeader = createHeader(roots);\n                if (!(reader.pos !== newHeader.length)) {\n                  _context3.next = 6;\n                  break;\n                }\n                throw new Error(\"updateRoots() can only overwrite a header of the same length (old header is \".concat(reader.pos, \" bytes, new header is \").concat(newHeader.length, \" bytes)\"));\n              case 6:\n                bytes.set(newHeader, 0);\n                return _context3.abrupt(\"return\", bytes);\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function updateRootsInBytes(_x2, _x3) {\n        return _updateRootsInBytes.apply(this, arguments);\n      }\n      return updateRootsInBytes;\n    }()\n  }]);\n  return CarWriter;\n}();\nexport var CarWriterOut = /*#__PURE__*/function (_Symbol$asyncIterator) {\n  function CarWriterOut(iterator) {\n    _classCallCheck(this, CarWriterOut);\n    this._iterator = iterator;\n  }\n  _createClass(CarWriterOut, [{\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      if (this._iterating) {\n        throw new Error('Multiple iterator not supported');\n      }\n      this._iterating = true;\n      return this._iterator;\n    }\n  }]);\n  return CarWriterOut;\n}(Symbol.asyncIterator);\nfunction encodeWriter() {\n  var iw = iteratorChannel();\n  var writer = iw.writer,\n    iterator = iw.iterator;\n  var encoder = createEncoder(writer);\n  return {\n    encoder: encoder,\n    iterator: iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    var cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  var _roots = [];\n  var _iterator = _createForOfIteratorHelper(roots),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var root = _step.value;\n      var _root = CID.asCID(root);\n      if (!_root) {\n        throw new TypeError('roots must be a single CID or an array of CIDs');\n      }\n      _roots.push(_root);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return _roots;\n}\nexport var __browser = true;","map":{"version":3,"names":["CID","createEncoder","createHeader","create","iteratorChannel","bytesReader","readHeader","CarWriter","roots","encoder","_encoder","_mutex","setRoots","_ended","block","bytes","Uint8Array","cid","TypeError","Error","asCID","then","writeBlock","close","toRoots","encodeWriter","iterator","writer","out","CarWriterOut","Promise","resolve","reader","newHeader","pos","length","set","_iterator","_iterating","Symbol","asyncIterator","iw","undefined","Array","isArray","_roots","root","_root","push","__browser"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@ipld/car/esm/lib/writer-browser.js"],"sourcesContent":["import { CID } from 'multiformats/cid';\nimport {\n  createEncoder,\n  createHeader\n} from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport {\n  bytesReader,\n  readHeader\n} from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {writer, iterator} = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}