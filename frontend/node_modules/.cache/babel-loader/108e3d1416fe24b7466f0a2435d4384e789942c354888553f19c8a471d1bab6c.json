{"ast":null,"code":"import _regeneratorRuntime from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nvar CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nfunction readVarint(_x) {\n  return _readVarint.apply(this, arguments);\n}\nfunction _readVarint() {\n  _readVarint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(reader) {\n    var bytes, i;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return reader.upTo(8);\n          case 2:\n            bytes = _context9.sent;\n            i = varint.decode(bytes);\n            reader.seek(varint.decode.bytes);\n            return _context9.abrupt(\"return\", i);\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _readVarint.apply(this, arguments);\n}\nexport function readHeader(_x2) {\n  return _readHeader.apply(this, arguments);\n}\nfunction _readHeader() {\n  _readHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(reader) {\n    var length, header, block;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return readVarint(reader);\n          case 2:\n            length = _context10.sent;\n            if (!(length === 0)) {\n              _context10.next = 5;\n              break;\n            }\n            throw new Error('Invalid CAR header (zero length)');\n          case 5:\n            _context10.next = 7;\n            return reader.exactly(length);\n          case 7:\n            header = _context10.sent;\n            reader.seek(length);\n            block = decodeDagCbor(header);\n            if (!(block == null || Array.isArray(block) || typeof block !== 'object')) {\n              _context10.next = 12;\n              break;\n            }\n            throw new Error('Invalid CAR header format');\n          case 12:\n            if (!(block.version !== 1)) {\n              _context10.next = 16;\n              break;\n            }\n            if (!(typeof block.version === 'string')) {\n              _context10.next = 15;\n              break;\n            }\n            throw new Error(\"Invalid CAR version: \\\"\".concat(block.version, \"\\\"\"));\n          case 15:\n            throw new Error(\"Invalid CAR version: \".concat(block.version));\n          case 16:\n            if (Array.isArray(block.roots)) {\n              _context10.next = 18;\n              break;\n            }\n            throw new Error('Invalid CAR header format');\n          case 18:\n            if (!Object.keys(block).filter(function (p) {\n              return p !== 'roots' && p !== 'version';\n            }).length) {\n              _context10.next = 20;\n              break;\n            }\n            throw new Error('Invalid CAR header format');\n          case 20:\n            return _context10.abrupt(\"return\", block);\n          case 21:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return _readHeader.apply(this, arguments);\n}\nfunction readMultihash(_x3) {\n  return _readMultihash.apply(this, arguments);\n}\nfunction _readMultihash() {\n  _readMultihash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(reader) {\n    var bytes, codeLength, length, lengthLength, mhLength, multihash;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return reader.upTo(8);\n          case 2:\n            bytes = _context11.sent;\n            varint.decode(bytes);\n            codeLength = varint.decode.bytes;\n            length = varint.decode(bytes.subarray(varint.decode.bytes));\n            lengthLength = varint.decode.bytes;\n            mhLength = codeLength + lengthLength + length;\n            _context11.next = 10;\n            return reader.exactly(mhLength);\n          case 10:\n            multihash = _context11.sent;\n            reader.seek(mhLength);\n            return _context11.abrupt(\"return\", multihash);\n          case 13:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _readMultihash.apply(this, arguments);\n}\nfunction readCid(_x4) {\n  return _readCid.apply(this, arguments);\n}\nfunction _readCid() {\n  _readCid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(reader) {\n    var first, _bytes, _multihash, version, codec, bytes, multihash;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return reader.exactly(2);\n          case 2:\n            first = _context12.sent;\n            if (!(first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH)) {\n              _context12.next = 10;\n              break;\n            }\n            _context12.next = 6;\n            return reader.exactly(34);\n          case 6:\n            _bytes = _context12.sent;\n            reader.seek(34);\n            _multihash = Digest.decode(_bytes);\n            return _context12.abrupt(\"return\", CID.create(0, CIDV0_BYTES.DAG_PB, _multihash));\n          case 10:\n            _context12.next = 12;\n            return readVarint(reader);\n          case 12:\n            version = _context12.sent;\n            if (!(version !== 1)) {\n              _context12.next = 15;\n              break;\n            }\n            throw new Error(\"Unexpected CID version (\".concat(version, \")\"));\n          case 15:\n            _context12.next = 17;\n            return readVarint(reader);\n          case 17:\n            codec = _context12.sent;\n            _context12.next = 20;\n            return readMultihash(reader);\n          case 20:\n            bytes = _context12.sent;\n            multihash = Digest.decode(bytes);\n            return _context12.abrupt(\"return\", CID.create(version, codec, multihash));\n          case 23:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _readCid.apply(this, arguments);\n}\nexport function readBlockHead(_x5) {\n  return _readBlockHead.apply(this, arguments);\n}\nfunction _readBlockHead() {\n  _readBlockHead = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(reader) {\n    var start, length, cid, blockLength;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            start = reader.pos;\n            _context13.next = 3;\n            return readVarint(reader);\n          case 3:\n            length = _context13.sent;\n            if (!(length === 0)) {\n              _context13.next = 6;\n              break;\n            }\n            throw new Error('Invalid CAR section (zero length)');\n          case 6:\n            length += reader.pos - start;\n            _context13.next = 9;\n            return readCid(reader);\n          case 9:\n            cid = _context13.sent;\n            blockLength = length - (reader.pos - start);\n            return _context13.abrupt(\"return\", {\n              cid: cid,\n              length: length,\n              blockLength: blockLength\n            });\n          case 12:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _readBlockHead.apply(this, arguments);\n}\nfunction readBlock(_x6) {\n  return _readBlock.apply(this, arguments);\n}\nfunction _readBlock() {\n  _readBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(reader) {\n    var _yield$readBlockHead, cid, blockLength, bytes;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.next = 2;\n            return readBlockHead(reader);\n          case 2:\n            _yield$readBlockHead = _context14.sent;\n            cid = _yield$readBlockHead.cid;\n            blockLength = _yield$readBlockHead.blockLength;\n            _context14.next = 7;\n            return reader.exactly(blockLength);\n          case 7:\n            bytes = _context14.sent;\n            reader.seek(blockLength);\n            return _context14.abrupt(\"return\", {\n              bytes: bytes,\n              cid: cid\n            });\n          case 10:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return _readBlock.apply(this, arguments);\n}\nfunction readBlockIndex(_x7) {\n  return _readBlockIndex.apply(this, arguments);\n}\nfunction _readBlockIndex() {\n  _readBlockIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(reader) {\n    var offset, _yield$readBlockHead2, cid, length, blockLength, index;\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            offset = reader.pos;\n            _context15.next = 3;\n            return readBlockHead(reader);\n          case 3:\n            _yield$readBlockHead2 = _context15.sent;\n            cid = _yield$readBlockHead2.cid;\n            length = _yield$readBlockHead2.length;\n            blockLength = _yield$readBlockHead2.blockLength;\n            index = {\n              cid: cid,\n              length: length,\n              blockLength: blockLength,\n              offset: offset,\n              blockOffset: reader.pos\n            };\n            reader.seek(index.blockLength);\n            return _context15.abrupt(\"return\", index);\n          case 10:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return _readBlockIndex.apply(this, arguments);\n}\nexport function createDecoder(reader) {\n  var headerPromise = readHeader(reader);\n  return {\n    header: function header() {\n      return headerPromise;\n    },\n    blocks: function blocks() {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _awaitAsyncGenerator(headerPromise);\n              case 2:\n                _context.next = 4;\n                return _awaitAsyncGenerator(reader.upTo(8));\n              case 4:\n                _context.t0 = _context.sent.length;\n                if (!(_context.t0 > 0)) {\n                  _context.next = 12;\n                  break;\n                }\n                _context.next = 8;\n                return _awaitAsyncGenerator(readBlock(reader));\n              case 8:\n                _context.next = 10;\n                return _context.sent;\n              case 10:\n                _context.next = 2;\n                break;\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    blocksIndex: function blocksIndex() {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _awaitAsyncGenerator(headerPromise);\n              case 2:\n                _context2.next = 4;\n                return _awaitAsyncGenerator(reader.upTo(8));\n              case 4:\n                _context2.t0 = _context2.sent.length;\n                if (!(_context2.t0 > 0)) {\n                  _context2.next = 12;\n                  break;\n                }\n                _context2.next = 8;\n                return _awaitAsyncGenerator(readBlockIndex(reader));\n              case 8:\n                _context2.next = 10;\n                return _context2.sent;\n              case 10:\n                _context2.next = 2;\n                break;\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  var pos = 0;\n  return {\n    upTo: function upTo(length) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", bytes.subarray(pos, pos + Math.min(length, bytes.length - pos)));\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n    exactly: function exactly(length) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(length > bytes.length - pos)) {\n                  _context4.next = 2;\n                  break;\n                }\n                throw new Error('Unexpected end of data');\n              case 2:\n                return _context4.abrupt(\"return\", bytes.subarray(pos, pos + length));\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n    seek: function seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  var pos = 0;\n  var have = 0;\n  var offset = 0;\n  var currentChunk = new Uint8Array(0);\n  var read = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(length) {\n      var bufa, chunk, off, _i, _bufa, b;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              have = currentChunk.length - offset;\n              bufa = [currentChunk.subarray(offset)];\n            case 2:\n              if (!(have < length)) {\n                _context5.next = 12;\n                break;\n              }\n              _context5.next = 5;\n              return readChunk();\n            case 5:\n              chunk = _context5.sent;\n              if (!(chunk == null)) {\n                _context5.next = 8;\n                break;\n              }\n              return _context5.abrupt(\"break\", 12);\n            case 8:\n              if (have < 0) {\n                if (chunk.length > have) {\n                  bufa.push(chunk.subarray(-have));\n                }\n              } else {\n                bufa.push(chunk);\n              }\n              have += chunk.length;\n              _context5.next = 2;\n              break;\n            case 12:\n              currentChunk = new Uint8Array(bufa.reduce(function (p, c) {\n                return p + c.length;\n              }, 0));\n              off = 0;\n              for (_i = 0, _bufa = bufa; _i < _bufa.length; _i++) {\n                b = _bufa[_i];\n                currentChunk.set(b, off);\n                off += b.length;\n              }\n              offset = 0;\n            case 16:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return function read(_x8) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return {\n    upTo: function upTo(length) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(currentChunk.length - offset < length)) {\n                  _context6.next = 3;\n                  break;\n                }\n                _context6.next = 3;\n                return read(length);\n              case 3:\n                return _context6.abrupt(\"return\", currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length)));\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    },\n    exactly: function exactly(length) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(currentChunk.length - offset < length)) {\n                  _context7.next = 3;\n                  break;\n                }\n                _context7.next = 3;\n                return read(length);\n              case 3:\n                if (!(currentChunk.length - offset < length)) {\n                  _context7.next = 5;\n                  break;\n                }\n                throw new Error('Unexpected end of data');\n              case 5:\n                return _context7.abrupt(\"return\", currentChunk.subarray(offset, offset + length));\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    },\n    seek: function seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  var iterator = asyncIterable[Symbol.asyncIterator]();\n  function readChunk() {\n    return _readChunk.apply(this, arguments);\n  }\n  function _readChunk() {\n    _readChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      var next;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return iterator.next();\n            case 2:\n              next = _context8.sent;\n              if (!next.done) {\n                _context8.next = 5;\n                break;\n              }\n              return _context8.abrupt(\"return\", null);\n            case 5:\n              return _context8.abrupt(\"return\", next.value);\n            case 6:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _readChunk.apply(this, arguments);\n  }\n  return chunkReader(readChunk);\n}","map":{"version":3,"names":["varint","CID","Digest","decode","decodeDagCbor","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","upTo","bytes","i","seek","readHeader","length","Error","exactly","header","block","Array","isArray","version","roots","Object","keys","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","create","codec","readBlockHead","start","pos","cid","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@ipld/car/esm/lib/decoder.js"],"sourcesContent":["import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}"],"mappings":";;;;AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAO,KAAKC,MAAM,MAAM,4BAA4B;AACpD,SAASC,MAAM,IAAIC,aAAa,QAAQ,gBAAgB;AACxD,IAAMC,WAAW,GAAG;EAClBC,QAAQ,EAAE,EAAE;EACZC,MAAM,EAAE,EAAE;EACVC,MAAM,EAAE;AACV,CAAC;AAAC,SACaC,UAAU;EAAA;AAAA;AAAA;EAAA,yEAAzB,kBAA0BC,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACVA,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC;UAAA;YAA5BC,KAAK;YACLC,CAAC,GAAGb,MAAM,CAACG,MAAM,CAACS,KAAK,CAAC;YAC9BF,MAAM,CAACI,IAAI,CAACd,MAAM,CAACG,MAAM,CAACS,KAAK,CAAC;YAAC,kCAC1BC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACT;EAAA;AAAA;AACD,gBAAsBE,UAAU;EAAA;AAAA;AAwB/B;EAAA,yEAxBM,mBAA0BL,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OAChBD,UAAU,CAACC,MAAM,CAAC;UAAA;YAAjCM,MAAM;YAAA,MACRA,MAAM,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MACR,IAAIC,KAAK,CAAC,kCAAkC,CAAC;UAAA;YAAA;YAAA,OAEhCP,MAAM,CAACQ,OAAO,CAACF,MAAM,CAAC;UAAA;YAArCG,MAAM;YACZT,MAAM,CAACI,IAAI,CAACE,MAAM,CAAC;YACbI,KAAK,GAAGhB,aAAa,CAACe,MAAM,CAAC;YAAA,MAC/BC,KAAK,IAAI,IAAI,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,IAAI,OAAOA,KAAK,KAAK,QAAQ;cAAA;cAAA;YAAA;YAAA,MAC9D,IAAIH,KAAK,CAAC,2BAA2B,CAAC;UAAA;YAAA,MAE1CG,KAAK,CAACG,OAAO,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MACjB,OAAOH,KAAK,CAACG,OAAO,KAAK,QAAQ;cAAA;cAAA;YAAA;YAAA,MAC7B,IAAIN,KAAK,kCAA2BG,KAAK,CAACG,OAAO,QAAK;UAAA;YAAA,MAExD,IAAIN,KAAK,gCAA0BG,KAAK,CAACG,OAAO,EAAI;UAAA;YAAA,IAEvDF,KAAK,CAACC,OAAO,CAACF,KAAK,CAACI,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MACvB,IAAIP,KAAK,CAAC,2BAA2B,CAAC;UAAA;YAAA,KAE1CQ,MAAM,CAACC,IAAI,CAACN,KAAK,CAAC,CAACO,MAAM,CAAC,UAAAC,CAAC;cAAA,OAAIA,CAAC,KAAK,OAAO,IAAIA,CAAC,KAAK,SAAS;YAAA,EAAC,CAACZ,MAAM;cAAA;cAAA;YAAA;YAAA,MACnE,IAAIC,KAAK,CAAC,2BAA2B,CAAC;UAAA;YAAA,mCAEvCG,KAAK;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACb;EAAA;AAAA;AAAA,SACcS,aAAa;EAAA;AAAA;AAAA;EAAA,4EAA5B,mBAA6BnB,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACbA,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC;UAAA;YAA5BC,KAAK;YACXZ,MAAM,CAACG,MAAM,CAACS,KAAK,CAAC;YACdkB,UAAU,GAAG9B,MAAM,CAACG,MAAM,CAACS,KAAK;YAChCI,MAAM,GAAGhB,MAAM,CAACG,MAAM,CAACS,KAAK,CAACmB,QAAQ,CAAC/B,MAAM,CAACG,MAAM,CAACS,KAAK,CAAC,CAAC;YAC3DoB,YAAY,GAAGhC,MAAM,CAACG,MAAM,CAACS,KAAK;YAClCqB,QAAQ,GAAGH,UAAU,GAAGE,YAAY,GAAGhB,MAAM;YAAA;YAAA,OAC3BN,MAAM,CAACQ,OAAO,CAACe,QAAQ,CAAC;UAAA;YAA1CC,SAAS;YACfxB,MAAM,CAACI,IAAI,CAACmB,QAAQ,CAAC;YAAC,mCACfC,SAAS;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACjB;EAAA;AAAA;AAAA,SACcC,OAAO;EAAA;AAAA;AAAA;EAAA,sEAAtB,mBAAuBzB,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACPA,MAAM,CAACQ,OAAO,CAAC,CAAC,CAAC;UAAA;YAA/BkB,KAAK;YAAA,MACPA,KAAK,CAAC,CAAC,CAAC,KAAK/B,WAAW,CAACC,QAAQ,IAAI8B,KAAK,CAAC,CAAC,CAAC,KAAK/B,WAAW,CAACE,MAAM;cAAA;cAAA;YAAA;YAAA;YAAA,OAClDG,MAAM,CAACQ,OAAO,CAAC,EAAE,CAAC;UAAA;YAAhCN,MAAK;YACXF,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;YACToB,UAAS,GAAGhC,MAAM,CAACC,MAAM,CAACS,MAAK,CAAC;YAAA,mCAC/BX,GAAG,CAACoC,MAAM,CAAC,CAAC,EAAEhC,WAAW,CAACG,MAAM,EAAE0B,UAAS,CAAC;UAAA;YAAA;YAAA,OAE/BzB,UAAU,CAACC,MAAM,CAAC;UAAA;YAAlCa,OAAO;YAAA,MACTA,OAAO,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MACT,IAAIN,KAAK,mCAA6BM,OAAO,OAAK;UAAA;YAAA;YAAA,OAEtCd,UAAU,CAACC,MAAM,CAAC;UAAA;YAAhC4B,KAAK;YAAA;YAAA,OACST,aAAa,CAACnB,MAAM,CAAC;UAAA;YAAnCE,KAAK;YACLsB,SAAS,GAAGhC,MAAM,CAACC,MAAM,CAACS,KAAK,CAAC;YAAA,mCAC/BX,GAAG,CAACoC,MAAM,CAACd,OAAO,EAAEe,KAAK,EAAEJ,SAAS,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAC7C;EAAA;AAAA;AACD,gBAAsBK,aAAa;EAAA;AAAA;AAclC;EAAA,4EAdM,mBAA6B7B,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAClC8B,KAAK,GAAG9B,MAAM,CAAC+B,GAAG;YAAA;YAAA,OACLhC,UAAU,CAACC,MAAM,CAAC;UAAA;YAAjCM,MAAM;YAAA,MACNA,MAAM,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MACR,IAAIC,KAAK,CAAC,mCAAmC,CAAC;UAAA;YAEtDD,MAAM,IAAIN,MAAM,CAAC+B,GAAG,GAAGD,KAAK;YAAC;YAAA,OACXL,OAAO,CAACzB,MAAM,CAAC;UAAA;YAA3BgC,GAAG;YACHC,WAAW,GAAG3B,MAAM,IAAIN,MAAM,CAAC+B,GAAG,GAAGD,KAAK,CAAC;YAAA,mCAC1C;cACLE,GAAG,EAAHA,GAAG;cACH1B,MAAM,EAANA,MAAM;cACN2B,WAAW,EAAXA;YACF,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAAA,SACcC,SAAS;EAAA;AAAA;AAAA;EAAA,wEAAxB,mBAAyBlC,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACI6B,aAAa,CAAC7B,MAAM,CAAC;UAAA;YAAA;YAA/CgC,GAAG,wBAAHA,GAAG;YAAEC,WAAW,wBAAXA,WAAW;YAAA;YAAA,OACHjC,MAAM,CAACQ,OAAO,CAACyB,WAAW,CAAC;UAAA;YAAzC/B,KAAK;YACXF,MAAM,CAACI,IAAI,CAAC6B,WAAW,CAAC;YAAC,mCAClB;cACL/B,KAAK,EAALA,KAAK;cACL8B,GAAG,EAAHA;YACF,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAAA,SACcG,cAAc;EAAA;AAAA;AAAA;EAAA,6EAA7B,mBAA8BnC,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAC5BoC,MAAM,GAAGpC,MAAM,CAAC+B,GAAG;YAAA;YAAA,OACgBF,aAAa,CAAC7B,MAAM,CAAC;UAAA;YAAA;YAAvDgC,GAAG,yBAAHA,GAAG;YAAE1B,MAAM,yBAANA,MAAM;YAAE2B,WAAW,yBAAXA,WAAW;YACzBI,KAAK,GAAG;cACZL,GAAG,EAAHA,GAAG;cACH1B,MAAM,EAANA,MAAM;cACN2B,WAAW,EAAXA,WAAW;cACXG,MAAM,EAANA,MAAM;cACNE,WAAW,EAAEtC,MAAM,CAAC+B;YACtB,CAAC;YACD/B,MAAM,CAACI,IAAI,CAACiC,KAAK,CAACJ,WAAW,CAAC;YAAC,mCACxBI,KAAK;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACb;EAAA;AAAA;AACD,OAAO,SAASE,aAAa,CAACvC,MAAM,EAAE;EACpC,IAAMwC,aAAa,GAAGnC,UAAU,CAACL,MAAM,CAAC;EACxC,OAAO;IACLS,MAAM,EAAE;MAAA,OAAM+B,aAAa;IAAA;IACpBC,MAAM,oBAAG;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,4BACRD,aAAa;cAAA;gBAAA;gBAAA,4BACLxC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC;cAAA;gBAAA,4BAAEK,MAAM;gBAAA,oBAAG,CAAC;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,4BAC1B4B,SAAS,CAAClC,MAAM,CAAC;cAAA;gBAAA;gBAA7B;cAA6B;gBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAEjC,CAAC;IACM0C,WAAW,yBAAG;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,4BACbF,aAAa;cAAA;gBAAA;gBAAA,4BACLxC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC;cAAA;gBAAA,8BAAEK,MAAM;gBAAA,qBAAG,CAAC;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,4BAC1B6B,cAAc,CAACnC,MAAM,CAAC;cAAA;gBAAA;gBAAlC;cAAkC;gBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAEtC;EACF,CAAC;AACH;AACA,OAAO,SAAS2C,WAAW,CAACzC,KAAK,EAAE;EACjC,IAAI6B,GAAG,GAAG,CAAC;EACX,OAAO;IACC9B,IAAI,gBAACK,MAAM,EAAE;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,kCACVJ,KAAK,CAACmB,QAAQ,CAACU,GAAG,EAAEA,GAAG,GAAGa,IAAI,CAACC,GAAG,CAACvC,MAAM,EAAEJ,KAAK,CAACI,MAAM,GAAGyB,GAAG,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IACxE,CAAC;IACKvB,OAAO,mBAACF,MAAM,EAAE;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAChBA,MAAM,GAAGJ,KAAK,CAACI,MAAM,GAAGyB,GAAG;kBAAA;kBAAA;gBAAA;gBAAA,MACvB,IAAIxB,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAAA,kCAEpCL,KAAK,CAACmB,QAAQ,CAACU,GAAG,EAAEA,GAAG,GAAGzB,MAAM,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAC1C,CAAC;IACDF,IAAI,gBAACE,MAAM,EAAE;MACXyB,GAAG,IAAIzB,MAAM;IACf,CAAC;IACD,IAAIyB,GAAG,GAAG;MACR,OAAOA,GAAG;IACZ;EACF,CAAC;AACH;AACA,OAAO,SAASe,WAAW,CAACC,SAAS,EAAE;EACrC,IAAIhB,GAAG,GAAG,CAAC;EACX,IAAIiB,IAAI,GAAG,CAAC;EACZ,IAAIZ,MAAM,GAAG,CAAC;EACd,IAAIa,YAAY,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC;EACpC,IAAMC,IAAI;IAAA,sEAAG,kBAAM7C,MAAM;MAAA;MAAA;QAAA;UAAA;YAAA;cACvB0C,IAAI,GAAGC,YAAY,CAAC3C,MAAM,GAAG8B,MAAM;cAC7BgB,IAAI,GAAG,CAACH,YAAY,CAAC5B,QAAQ,CAACe,MAAM,CAAC,CAAC;YAAA;cAAA,MACrCY,IAAI,GAAG1C,MAAM;gBAAA;gBAAA;cAAA;cAAA;cAAA,OACEyC,SAAS,EAAE;YAAA;cAAzBM,KAAK;cAAA,MACPA,KAAK,IAAI,IAAI;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAGjB,IAAIL,IAAI,GAAG,CAAC,EAAE;gBACZ,IAAIK,KAAK,CAAC/C,MAAM,GAAG0C,IAAI,EAAE;kBACvBI,IAAI,CAACE,IAAI,CAACD,KAAK,CAAChC,QAAQ,CAAC,CAAC2B,IAAI,CAAC,CAAC;gBAClC;cACF,CAAC,MAAM;gBACLI,IAAI,CAACE,IAAI,CAACD,KAAK,CAAC;cAClB;cACAL,IAAI,IAAIK,KAAK,CAAC/C,MAAM;cAAC;cAAA;YAAA;cAEvB2C,YAAY,GAAG,IAAIC,UAAU,CAACE,IAAI,CAACG,MAAM,CAAC,UAACrC,CAAC,EAAEsC,CAAC;gBAAA,OAAKtC,CAAC,GAAGsC,CAAC,CAAClD,MAAM;cAAA,GAAE,CAAC,CAAC,CAAC;cACjEmD,GAAG,GAAG,CAAC;cACX,qBAAgBL,IAAI,2BAAE;gBAAXM,CAAC;gBACVT,YAAY,CAACU,GAAG,CAACD,CAAC,EAAED,GAAG,CAAC;gBACxBA,GAAG,IAAIC,CAAC,CAACpD,MAAM;cACjB;cACA8B,MAAM,GAAG,CAAC;YAAC;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CACZ;IAAA,gBAxBKe,IAAI;MAAA;IAAA;EAAA,GAwBT;EACD,OAAO;IACClD,IAAI,gBAACK,MAAM,EAAE;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MACb2C,YAAY,CAAC3C,MAAM,GAAG8B,MAAM,GAAG9B,MAAM;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACjC6C,IAAI,CAAC7C,MAAM,CAAC;cAAA;gBAAA,kCAEb2C,YAAY,CAAC5B,QAAQ,CAACe,MAAM,EAAEA,MAAM,GAAGQ,IAAI,CAACC,GAAG,CAACI,YAAY,CAAC3C,MAAM,GAAG8B,MAAM,EAAE9B,MAAM,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAC/F,CAAC;IACKE,OAAO,mBAACF,MAAM,EAAE;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAChB2C,YAAY,CAAC3C,MAAM,GAAG8B,MAAM,GAAG9B,MAAM;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACjC6C,IAAI,CAAC7C,MAAM,CAAC;cAAA;gBAAA,MAEhB2C,YAAY,CAAC3C,MAAM,GAAG8B,MAAM,GAAG9B,MAAM;kBAAA;kBAAA;gBAAA;gBAAA,MACjC,IAAIC,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAAA,kCAEpC0C,YAAY,CAAC5B,QAAQ,CAACe,MAAM,EAAEA,MAAM,GAAG9B,MAAM,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IACvD,CAAC;IACDF,IAAI,gBAACE,MAAM,EAAE;MACXyB,GAAG,IAAIzB,MAAM;MACb8B,MAAM,IAAI9B,MAAM;IAClB,CAAC;IACD,IAAIyB,GAAG,GAAG;MACR,OAAOA,GAAG;IACZ;EACF,CAAC;AACH;AACA,OAAO,SAAS6B,mBAAmB,CAACC,aAAa,EAAE;EACjD,IAAMC,QAAQ,GAAGD,aAAa,CAACE,MAAM,CAACC,aAAa,CAAC,EAAE;EAAC,SACxCjB,SAAS;IAAA;EAAA;EAAA;IAAA,wEAAxB;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OACqBe,QAAQ,CAACG,IAAI,EAAE;YAAA;cAA5BA,IAAI;cAAA,KACNA,IAAI,CAACC,IAAI;gBAAA;gBAAA;cAAA;cAAA,kCACJ,IAAI;YAAA;cAAA,kCAEND,IAAI,CAACE,KAAK;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAClB;IAAA;EAAA;EACD,OAAOrB,WAAW,CAACC,SAAS,CAAC;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}