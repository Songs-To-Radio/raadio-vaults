{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar ConsumableBuffer = require('./consumable-buffer');\nvar _require = require('uint8arrays/concat'),\n  uint8ArrayConcat = _require.concat;\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash(hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  }\n  return hashing;\n}\nvar InfiniteHash = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  function InfiniteHash(value, hashFn) {\n    _classCallCheck(this, InfiniteHash);\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays');\n    }\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = [];\n  }\n\n  /**\n   * @param {number} bits\n   */\n  _createClass(InfiniteHash, [{\n    key: \"take\",\n    value: function () {\n      var _take = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bits) {\n        var pendingBits, result, hash, available, took;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pendingBits = bits;\n              case 1:\n                if (!(this._availableBits < pendingBits)) {\n                  _context.next = 6;\n                  break;\n                }\n                _context.next = 4;\n                return this._produceMoreBits();\n              case 4:\n                _context.next = 1;\n                break;\n              case 6:\n                result = 0;\n                while (pendingBits > 0) {\n                  hash = this._buffers[this._currentBufferIndex];\n                  available = Math.min(hash.availableBits(), pendingBits);\n                  took = hash.take(available);\n                  result = (result << available) + took;\n                  pendingBits -= available;\n                  this._availableBits -= available;\n                  if (hash.availableBits() === 0) {\n                    this._currentBufferIndex++;\n                  }\n                }\n                return _context.abrupt(\"return\", result);\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function take(_x) {\n        return _take.apply(this, arguments);\n      }\n      return take;\n    }()\n    /**\n     * @param {number} bits\n     */\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      var pendingBits = bits;\n      while (pendingBits > 0) {\n        var hash = this._buffers[this._currentBufferIndex];\n        var availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n        hash.untake(availableForUntake);\n        pendingBits -= availableForUntake;\n        this._availableBits += availableForUntake;\n        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n          this._depth--;\n          this._currentBufferIndex--;\n        }\n      }\n    }\n  }, {\n    key: \"_produceMoreBits\",\n    value: function () {\n      var _produceMoreBits2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var value, hashValue, buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._depth++;\n                value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;\n                _context2.next = 4;\n                return this._hashFn(value);\n              case 4:\n                hashValue = _context2.sent;\n                buffer = new ConsumableBuffer(hashValue);\n                this._buffers.push(buffer);\n                this._availableBits += buffer.availableBits();\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function _produceMoreBits() {\n        return _produceMoreBits2.apply(this, arguments);\n      }\n      return _produceMoreBits;\n    }()\n  }]);\n  return InfiniteHash;\n}();\nmodule.exports = wrapHash;\nmodule.exports.InfiniteHash = InfiniteHash;","map":{"version":3,"names":["ConsumableBuffer","require","uint8ArrayConcat","concat","wrapHash","hashFn","hashing","value","InfiniteHash","Uint8Array","Error","_value","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","bits","pendingBits","_produceMoreBits","result","hash","available","Math","min","availableBits","took","take","availableForUntake","totalBits","untake","from","hashValue","buffer","push","module","exports"],"sources":["/Users/macbook/Desktop/BlockChain Projects/Hackerthon/frontend/node_modules/hamt-sharding/src/consumable-hash.js"],"sourcesContent":["'use strict'\n\nconst ConsumableBuffer = require('./consumable-buffer')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n"],"mappings":"AAAA,YAAY;;AAAA;AAAA;AAAA;AAAA;AAEZ,IAAMA,gBAAgB,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AACvD,eAAqCA,OAAO,CAAC,oBAAoB,CAAC;EAAlDC,gBAAgB,YAAxBC,MAAM;;AAEd;AACA;AACA;AACA,SAASC,QAAQ,CAAEC,MAAM,EAAE;EACzB;AACF;AACA;EACE,SAASC,OAAO,CAAEC,KAAK,EAAE;IACvB,IAAIA,KAAK,YAAYC,YAAY,EAAE;MACjC;MACA,OAAOD,KAAK;IACd,CAAC,MAAM;MACL,OAAO,IAAIC,YAAY,CAACD,KAAK,EAAEF,MAAM,CAAC;IACxC;EACF;EAEA,OAAOC,OAAO;AAChB;AAAC,IAEKE,YAAY;EAChB;AACF;AACA;AACA;AACA;EACE,sBAAaD,KAAK,EAAEF,MAAM,EAAE;IAAA;IAC1B,IAAI,EAAEE,KAAK,YAAYE,UAAU,CAAC,EAAE;MAClC,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IAEA,IAAI,CAACC,MAAM,GAAGJ,KAAK;IACnB,IAAI,CAACK,OAAO,GAAGP,MAAM;IACrB,IAAI,CAACQ,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,mBAAmB,GAAG,CAAC;;IAE5B;IACA,IAAI,CAACC,QAAQ,GAAG,EAAE;EACpB;;EAEA;AACF;AACA;EAFE;IAAA;IAAA;MAAA,uEAGA,iBAAYC,IAAI;QAAA;QAAA;UAAA;YAAA;cAAA;gBACVC,WAAW,GAAGD,IAAI;cAAA;gBAAA,MAEf,IAAI,CAACH,cAAc,GAAGI,WAAW;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAChC,IAAI,CAACC,gBAAgB,EAAE;cAAA;gBAAA;gBAAA;cAAA;gBAG3BC,MAAM,GAAG,CAAC;gBAEd,OAAOF,WAAW,GAAG,CAAC,EAAE;kBAChBG,IAAI,GAAG,IAAI,CAACL,QAAQ,CAAC,IAAI,CAACD,mBAAmB,CAAC;kBAC9CO,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACH,IAAI,CAACI,aAAa,EAAE,EAAEP,WAAW,CAAC;kBACvDQ,IAAI,GAAGL,IAAI,CAACM,IAAI,CAACL,SAAS,CAAC;kBACjCF,MAAM,GAAG,CAACA,MAAM,IAAIE,SAAS,IAAII,IAAI;kBACrCR,WAAW,IAAII,SAAS;kBACxB,IAAI,CAACR,cAAc,IAAIQ,SAAS;kBAEhC,IAAID,IAAI,CAACI,aAAa,EAAE,KAAK,CAAC,EAAE;oBAC9B,IAAI,CAACV,mBAAmB,EAAE;kBAC5B;gBACF;gBAAC,iCAEMK,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;AACF;AACA;EAFE;IAAA;IAAA,OAGA,gBAAQH,IAAI,EAAE;MACZ,IAAIC,WAAW,GAAGD,IAAI;MAEtB,OAAOC,WAAW,GAAG,CAAC,EAAE;QACtB,IAAMG,IAAI,GAAG,IAAI,CAACL,QAAQ,CAAC,IAAI,CAACD,mBAAmB,CAAC;QACpD,IAAMa,kBAAkB,GAAGL,IAAI,CAACC,GAAG,CAACH,IAAI,CAACQ,SAAS,EAAE,GAAGR,IAAI,CAACI,aAAa,EAAE,EAAEP,WAAW,CAAC;QACzFG,IAAI,CAACS,MAAM,CAACF,kBAAkB,CAAC;QAC/BV,WAAW,IAAIU,kBAAkB;QACjC,IAAI,CAACd,cAAc,IAAIc,kBAAkB;QAEzC,IAAI,IAAI,CAACb,mBAAmB,GAAG,CAAC,IAAIM,IAAI,CAACQ,SAAS,EAAE,KAAKR,IAAI,CAACI,aAAa,EAAE,EAAE;UAC7E,IAAI,CAACZ,MAAM,EAAE;UACb,IAAI,CAACE,mBAAmB,EAAE;QAC5B;MACF;IACF;EAAC;IAAA;IAAA;MAAA,mFAED;QAAA;QAAA;UAAA;YAAA;cAAA;gBACE,IAAI,CAACF,MAAM,EAAE;gBAEPN,KAAK,GAAG,IAAI,CAACM,MAAM,GAAGX,gBAAgB,CAAC,CAAC,IAAI,CAACS,MAAM,EAAEF,UAAU,CAACsB,IAAI,CAAC,CAAC,IAAI,CAAClB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACF,MAAM;gBAAA;gBAAA,OACjF,IAAI,CAACC,OAAO,CAACL,KAAK,CAAC;cAAA;gBAArCyB,SAAS;gBACTC,MAAM,GAAG,IAAIjC,gBAAgB,CAACgC,SAAS,CAAC;gBAE9C,IAAI,CAAChB,QAAQ,CAACkB,IAAI,CAACD,MAAM,CAAC;gBAC1B,IAAI,CAACnB,cAAc,IAAImB,MAAM,CAACR,aAAa,EAAE;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC9C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAGHU,MAAM,CAACC,OAAO,GAAGhC,QAAQ;AACzB+B,MAAM,CAACC,OAAO,CAAC5B,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}